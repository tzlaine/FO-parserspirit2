Index: universe/Condition_2.cpp
===================================================================
--- universe/Condition_2.cpp	(revision 0)
+++ universe/Condition_2.cpp	(revision 0)
@@ -0,0 +1,5189 @@
+#include "Condition_2.h"
+
+#include "../util/AppInterface.h"
+#include "../util/Random.h"
+#include "UniverseObject.h"
+#include "Building.h"
+#include "Fleet.h"
+#include "Ship.h"
+#include "Planet.h"
+#include "System.h"
+#include "Species.h"
+#include "Meter.h"
+#include "ValueRef_2.h"
+#include "../Empire/Empire.h"
+#include "../Empire/EmpireManager.h"
+
+#include <boost/graph/adjacency_list.hpp>
+#include <boost/graph/st_connected.hpp>
+
+using boost::io::str;
+
+extern int g_indent;
+
+namespace {
+    const Fleet* FleetFromObject(const UniverseObject* obj)
+    {
+        const ObjectMap& objects = GetMainObjectMap();
+        const Fleet* retval = universe_object_cast<const Fleet*>(obj);
+        if (!retval) {
+            if (const Ship* ship = universe_object_cast<const Ship*>(obj))
+                retval = objects.Object<Fleet>(ship->FleetID());
+        }
+        return retval;
+    }
+}
+
+///////////////////////////////////////////////////////////
+// Condition_2::ConditionBase                              //
+///////////////////////////////////////////////////////////
+Condition_2::ConditionBase::ConditionBase()
+{}
+
+Condition_2::ConditionBase::~ConditionBase()
+{}
+
+void Condition_2::ConditionBase::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+    ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+    ObjectSet::iterator it = from_set.begin();
+    ObjectSet::iterator end_it = from_set.end();
+    for ( ; it != end_it; ) {
+        ObjectSet::iterator temp = it++;
+        bool match = Match(ScriptingContext(parent_context, *temp));
+        if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+            to_set.insert(*temp);
+            from_set.erase(temp);
+        }
+    }
+}
+
+void Condition_2::ConditionBase::Eval(ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    Eval(ScriptingContext(), matches, non_matches, search_domain);
+}
+
+std::string Condition_2::ConditionBase::Description(bool negated/* = false*/) const
+{ return ""; }
+
+std::string Condition_2::ConditionBase::Dump() const
+{ return ""; }
+
+bool Condition_2::ConditionBase::Match(const ScriptingContext& local_context) const
+{ return false; }
+
+///////////////////////////////////////////////////////////
+// Number                                                //
+///////////////////////////////////////////////////////////
+Condition_2::Number::Number(const ValueRef_2::Int& low, const ValueRef_2::Int& high, const ConditionBase* condition) :
+    m_low(low),
+    m_high(high),
+    m_condition(condition)
+{}
+
+Condition_2::Number::~Number()
+{ delete m_condition; }
+
+std::string Condition_2::Number::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                                boost::lexical_cast<std::string>(m_high->Eval()) :
+                                Description(m_high);
+    std::string description_str = "DESC_NUMBER";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % low_str
+               % high_str
+               % m_condition->Description());
+}
+
+std::string Condition_2::Number::Dump() const
+{
+    std::string retval = DumpIndent() + "Number low = " + Dump(m_low) + "Number high = " + Dump(m_high) + " condition =\n";
+    ++g_indent;
+    retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+void Condition_2::Number::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    // Number does not have a single valid local candidate to be matched, as it
+    // will match anything if the proper number of objects match the
+    // subcondition.  So, the local context that is passed to the subcondition
+    // needs to have a null local candidate.
+    const UniverseObject* no_object(0);
+    ScriptingContext local_context(parent_context, no_object);
+
+    bool in_range = false;
+    if (!(LocalCandidateInvariant(m_low) && LocalCandidateInvariant(m_high))) {
+        Logger().errorStream() << "Condition_2::Number::Eval has local candidate-dependent ValueRefs, but no valid local candidate!";
+    } else if (!local_context.condition_root_candidate && !(RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high))) {
+        Logger().errorStream() << "Condition_2::Number::Eval has root candidate-dependent ValueRefs, but expects local candidate to be the root candidate, and has no valid local candidate!";
+    } else {
+        // get set of all UniverseObjects that satisfy m_condition
+        ObjectSet condition_targets;
+        ObjectSet condition_non_targets;
+        ObjectMap& objects = GetUniverse().Objects();
+        for (ObjectMap::iterator uit = objects.begin(); uit != objects.end(); ++uit) {
+            condition_non_targets.insert(uit->second);
+        }
+        m_condition->Eval(local_context, condition_targets, condition_non_targets, NON_MATCHES);
+
+        // compare number of objects that satisfy m_condition to the acceptable range of such objects
+        int matched = condition_targets.size();
+        int low = m_low->Eval(local_context);
+        int high = m_high->Eval(local_context);
+        in_range = (low <= matched && matched < high);
+    }
+
+    // transfer objects to or from candidate set, according to whether number of matches was within
+    // the requested range.
+    if (search_domain == MATCHES && !in_range) {
+        non_matches.insert(matches.begin(), matches.end());
+        matches.clear();
+    }
+    if (search_domain == NON_MATCHES && in_range) {
+        matches.insert(non_matches.begin(), non_matches.end());
+        non_matches.clear();
+    }
+}
+
+bool Condition_2::Number::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high) && m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::Number::TargetInvariant() const
+{ return TargetInvariant(m_low) && TargetInvariant(m_high) && m_condition->TargetInvariant(); }
+
+///////////////////////////////////////////////////////////
+// Turn                                                  //
+///////////////////////////////////////////////////////////
+Condition_2::Turn::Turn(const ValueRef_2::Int& low, const ValueRef_2::Int& high) :
+    m_low(low),
+    m_high(high)
+{}
+
+void Condition_2::Turn::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    // if ValueRef for low or high range limits depend on local candidate, then
+    // they must be evaluated per-candidate.
+    // if there already is a root candidate, then this condition's parameters
+    // can be evaluated assuming it will not change.
+    // if there is no root candidate in the parent context, then this
+    // condition's candidates will be the root candidates, and this condition's
+    // parameters must be root candidate invariant or else must be evaluated
+    // per-candidate
+    bool simple_eval_safe = (LocalCandidateInvariant(m_low) && LocalCandidateInvariant(m_high) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate turn limits once, check range, and use result to match or
+        // reject all the search domain, since the current turn doesn't change
+        // from object to object, and neither do the range limits.
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        int low =  std::max(0, m_low->Eval(local_context));
+        int high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+        int turn = CurrentTurn();
+        bool match = (low <= turn && turn < high);
+
+        if (match && search_domain == NON_MATCHES) {
+            // move all objects from non_matches to matches
+            matches.insert(non_matches.begin(), non_matches.end());
+            non_matches.clear();
+        } else if (!match && search_domain == MATCHES) {
+            // move all objects from matches to non_matches
+            non_matches.insert(matches.begin(), matches.end());
+            matches.clear();
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Turn::RootCandidateInvariant() const
+{ return (RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high)); }
+
+bool Condition_2::Turn::TargetInvariant() const
+{ return (TargetInvariant(m_low) && TargetInvariant(m_high)); }
+
+std::string Condition_2::Turn::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                            boost::lexical_cast<std::string>(m_high->Eval()) :
+                            Description(m_high);
+    std::string description_str = "DESC_TURN";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % low_str
+               % high_str);
+}
+
+std::string Condition_2::Turn::Dump() const
+{
+    return DumpIndent() + "Turn low = " + Dump(m_low) + " high = " + Dump(m_high) + "\n";
+}
+
+bool Condition_2::Turn::Match(const ScriptingContext& local_context) const
+{
+    double low = std::max(0, m_low->Eval(local_context));
+    double high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+    int turn = CurrentTurn();
+
+    return (low <= turn && turn < high);
+}
+
+///////////////////////////////////////////////////////////
+// SortedNumberOf                                        //
+///////////////////////////////////////////////////////////
+Condition_2::SortedNumberOf::SortedNumberOf(const ValueRef_2::Int& number,
+                                          const ConditionBase* condition) :
+    m_number(number),
+    m_sort_key(0),
+    m_sorting_method(Condition_2::SORT_RANDOM),
+    m_condition(condition)
+{}
+
+Condition_2::SortedNumberOf::SortedNumberOf(const ValueRef_2::Int& number,
+                                          const ValueRef_2::Double& sort_key,
+                                          SortingMethod sorting_method,
+                                          const ConditionBase* condition) :
+    m_number(number),
+    m_sort_key(sort_key),
+    m_sorting_method(sorting_method),
+    m_condition(condition)
+{}
+
+Condition_2::SortedNumberOf::~SortedNumberOf()
+{ delete m_condition; }
+
+namespace {
+    /** Random number genrator function to use with random_shuffle */
+    int CustomRandInt(int max_plus_one) {
+        return RandSmallInt(0, max_plus_one - 1);
+    }
+    int (*CRI)(int) = CustomRandInt;
+
+    /** Transfers the indicated \a number of objects, randomly selected from from_set to to_set */
+    void TransferRandomObjects(unsigned int number, Condition_2::ObjectSet& from_set, Condition_2::ObjectSet& to_set) {
+        // ensure number of objects to be moved is within reasonable range
+        number = std::min<unsigned int>(number, from_set.size());
+        if (number == 0)
+            return;
+
+        // create list of bool flags to indicate whether each item in from_set
+        // with corresponding place in iteration order should be transfered
+        std::vector<bool> transfer_flags(from_set.size(), false);   // initialized to all false
+
+        // set first  number  flags to true
+        std::fill_n(transfer_flags.begin(), number, true);
+
+        // shuffle flags to randomize which flags are set
+        std::random_shuffle(transfer_flags.begin(), transfer_flags.end(), CRI);
+
+        // transfer objects that have been flagged
+        int i = 0;
+        for (Condition_2::ObjectSet::iterator it = from_set.begin() ; it != from_set.end(); ++i) {
+            Condition_2::ObjectSet::iterator temp = it++;
+            if (transfer_flags[i]) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    }
+
+    /** Transfers the indicated \a number of objects, selected from \a from_set
+      * into \a to_set.  The objects transferred are selected based on the value
+      * of \a sort_key evaluated on them, with the largest / smallest / most
+      * common sort keys chosen, or a random selection chosen, depending on the
+      * specified \a sorting_method */
+    void TransferSortedObjects(unsigned int number, const ValueRef_2::Double& sort_key,
+                               const ScriptingContext& context, Condition_2::SortingMethod sorting_method,
+                               Condition_2::ObjectSet& from_set, Condition_2::ObjectSet& to_set)
+    {
+        // handle random case, which doesn't need sorting key
+        if (sorting_method == Condition_2::SORT_RANDOM) {
+            TransferRandomObjects(number, from_set, to_set);
+            return;
+        }
+
+        // for other SoringMethods, need sort key values
+        if (!sort_key) {
+            Logger().errorStream() << "TransferSortedObjects given null sort_key";
+            return;
+        }
+
+        // get sort key values for all objects in from_set, and sort by inserting into map
+        std::multimap<double, const UniverseObject*> sort_key_objects;
+        for (Condition_2::ObjectSet::const_iterator it = from_set.begin(); it != from_set.end(); ++it) {
+            double sort_value = sort_key->Eval(ScriptingContext(context, *it));
+            sort_key_objects.insert(std::make_pair(sort_value, *it));
+        }
+
+        // how many objects to select?
+        number = std::min<unsigned int>(number, sort_key_objects.size());
+        if (number == 0)
+            return;
+        unsigned int number_transferred(0);
+
+        // pick max / min / most common values
+        if (sorting_method == Condition_2::SORT_MIN) {
+            // move (number) objects with smallest sort key (at start of map)
+            // from the from_set into the to_set.
+            for (std::multimap<double, const UniverseObject*>::const_iterator sorted_it = sort_key_objects.begin();
+                 sorted_it != sort_key_objects.end(); ++sorted_it)
+            {
+                const UniverseObject* object_to_transfer = sorted_it->second;
+                Condition_2::ObjectSet::iterator from_it = from_set.find(object_to_transfer);
+                if (from_it != from_set.end()) {
+                    from_set.erase(from_it);
+                    to_set.insert(object_to_transfer);
+                    number_transferred++;
+                    if (number_transferred >= number)
+                        return;
+                }
+            }
+        } else if (sorting_method == Condition_2::SORT_MAX) {
+            // move (number) objects with largest sort key (at end of map)
+            // from the from_set into the to_set.
+            for (std::multimap<double, const UniverseObject*>::reverse_iterator sorted_it = sort_key_objects.rbegin();  // would use const_reverse_iterator but this causes a compile error in some compilers
+                 sorted_it != sort_key_objects.rend(); ++sorted_it)
+            {
+                const UniverseObject* object_to_transfer = sorted_it->second;
+                Condition_2::ObjectSet::iterator from_it = from_set.find(object_to_transfer);
+                if (from_it != from_set.end()) {
+                    from_set.erase(from_it);
+                    to_set.insert(object_to_transfer);
+                    number_transferred++;
+                    if (number_transferred >= number)
+                        return;                }
+            }
+        } else if (sorting_method == Condition_2::SORT_MODE) {
+            // compile histogram of of number of times each sort key occurs
+            std::map<double, unsigned int> histogram;
+            for (std::multimap<double, const UniverseObject*>::const_iterator sorted_it = sort_key_objects.begin();
+                 sorted_it != sort_key_objects.end(); ++sorted_it)
+            {
+                histogram[sorted_it->first]++;
+            }
+            // invert histogram to index by number of occurances
+            std::multimap<unsigned int, double> inv_histogram;
+            for (std::map<double, unsigned int>::const_iterator hist_it = histogram.begin();
+                 hist_it != histogram.end(); ++hist_it)
+            {
+                inv_histogram.insert(std::make_pair(hist_it->second, hist_it->first));
+            }
+            // reverse-loop through inverted histogram to find which sort keys
+            // occurred most frequently, and transfer objects with those sort
+            // keys from from_set to to_set.
+            for (std::multimap<unsigned int, double>::reverse_iterator inv_hist_it = inv_histogram.rbegin();  // would use const_reverse_iterator but this causes a compile error in some compilers
+                 inv_hist_it != inv_histogram.rend(); ++inv_hist_it)
+            {
+                double cur_sort_key = inv_hist_it->second;
+
+                // get range of objects with the current sort key
+                std::pair<std::multimap<double, const UniverseObject*>::const_iterator,
+                          std::multimap<double, const UniverseObject*>::const_iterator> key_range =
+                    sort_key_objects.equal_range(cur_sort_key);
+
+                // loop over range, selecting objects to transfer from from_set to to_set
+                for (std::multimap<double, const UniverseObject*>::const_iterator sorted_it = key_range.first;
+                     sorted_it != key_range.second; ++sorted_it)
+                {
+                    const UniverseObject* object_to_transfer = sorted_it->second;
+                    Condition_2::ObjectSet::iterator from_it = from_set.find(object_to_transfer);
+                    if (from_it != from_set.end()) {
+                        from_set.erase(from_it);
+                        to_set.insert(object_to_transfer);
+                        number_transferred++;
+                        if (number_transferred >= number)
+                            return;
+                    }
+                }
+            }
+        } else {
+            Logger().debugStream() << "TransferSortedObjects given unknown sort method";
+        }
+    }
+}
+
+void Condition_2::SortedNumberOf::Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                                     Condition_2::ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    // Most conditions match objects independently of the other objects being
+    // tested, but the number parameter for NumberOf conditions makes things
+    // more complicated.  In order to match some number of the potential
+    // matchs property, both the matches and non_matches need to be checked
+    // against the subcondition, and the total number of subcondition matches
+    // counted.
+    // Then, when searching NON_MATCHES, non_matches may be moved into matches
+    // so that the number of subcondition matches in matches is equal to the
+    // requested number.  There may also be subcondition non-matches in
+    // matches, but these are not counted or affected by this condition.
+    // Or, when searching MATCHES, matches may be moved into non_matches so
+    // that the number of subcondition matches in matches is equal to the
+    // requested number.  There again may be subcondition non-matches in
+    // matches, but these are also not counted or affected by this condition.
+
+    // SortedNumberOf does not have a valid local candidate to be matched
+    // before the subcondition is evaluated, so the local context that is
+    // passed to the subcondition needs to have a null local candidate.
+    const UniverseObject* no_object(0);
+    ScriptingContext local_context(parent_context, no_object);
+
+    // which input matches match the subcondition?
+    ObjectSet subcondition_matching_targets;
+    m_condition->Eval(local_context, subcondition_matching_targets, matches, NON_MATCHES);
+
+    // remaining input matches don't match the subcondition...
+    ObjectSet subcondition_non_matching_targets = matches;
+    matches.clear();    // to be refilled later
+
+    // which input non_matches match the subcondition?
+    ObjectSet subcondition_matching_non_targets;
+    m_condition->Eval(local_context, subcondition_matching_non_targets, non_matches, NON_MATCHES);
+
+    // remaining input non_matches don't match the subcondition...
+    ObjectSet subcondition_non_matching_non_targets = non_matches;
+    non_matches.clear();    // to be refilled later
+
+    // assemble single set of subcondition matching objects
+    ObjectSet all_subcondition_matches = subcondition_matching_targets;
+    all_subcondition_matches.insert(subcondition_matching_non_targets.begin(), subcondition_matching_non_targets.end());
+
+    // how many subcondition matches to select as matches to this condition
+    int number = m_number->Eval(local_context);
+
+    // compile single set of all objects that are matched by this condition.
+    // these are the objects that should be transferred from non_matches into
+    // matches, or those left in matches while the rest are moved into non_matches
+    ObjectSet matched_objects;
+    TransferSortedObjects(number, m_sort_key, local_context, m_sorting_method, all_subcondition_matches, matched_objects);
+
+    // put objects back into matches and non_target sets as output...
+
+    if (search_domain == NON_MATCHES) {
+        // put matched objects that are in subcondition_matching_non_targets into matches
+        for (ObjectSet::const_iterator match_it = matched_objects.begin(); match_it != matched_objects.end(); ++match_it) {
+            const UniverseObject* matched_object = *match_it;
+
+            // is this matched object in subcondition_matching_non_targets?
+            ObjectSet::iterator smnt_it = subcondition_matching_non_targets.find(matched_object);
+            if (smnt_it != subcondition_matching_non_targets.end()) {
+                // yes; move object to matches
+                subcondition_matching_non_targets.erase(smnt_it);
+                matches.insert(matched_object);
+            }
+        }
+
+        // put remaining (non-matched) objects in subcondition_matching_non_targets back into non_matches
+        non_matches.insert( subcondition_matching_non_targets.begin(),      subcondition_matching_non_targets.end());
+        // put objects in subcondition_non_matching_non_targets back into non_matches
+        non_matches.insert( subcondition_non_matching_non_targets.begin(),  subcondition_non_matching_non_targets.end());
+        // put objects in subcondition_matching_targets and subcondition_non_matching_targets back into matches
+        matches.insert(     subcondition_matching_targets.begin(),          subcondition_matching_targets.end());
+        matches.insert(     subcondition_non_matching_targets.begin(),      subcondition_non_matching_targets.end());
+        // this leaves the original contents of matches unchanged, other than
+        // possibly having transferred some objects into matches from non_matches
+
+    } else { /*(search_domain == MATCHES)*/
+        // put matched objecs that are in subcondition_matching_targets back into matches
+        for (ObjectSet::const_iterator match_it = matched_objects.begin(); match_it != matched_objects.end(); ++match_it) {
+            const UniverseObject* matched_object = *match_it;
+
+            // is this matched object in subcondition_matching_targets?
+            ObjectSet::iterator smt_it = subcondition_matching_targets.find(matched_object);
+            if (smt_it != subcondition_matching_targets.end()) {
+                // yes; move back into matches
+                subcondition_matching_targets.erase(smt_it);
+                matches.insert(matched_object);
+            }
+        }
+
+        // put remaining (non-matched) objects in subcondition_matching_targets) into non_matches
+        non_matches.insert( subcondition_matching_targets.begin(),          subcondition_matching_targets.end());
+        // put objects in subcondition_non_matching_targets into non_matches
+        non_matches.insert( subcondition_non_matching_targets.begin(),      subcondition_non_matching_targets.end());
+        // put objects in subcondition_matching_non_targets and subcondition_non_matching_non_targets back into non_matches
+        non_matches.insert( subcondition_matching_non_targets.begin(),      subcondition_matching_non_targets.end());
+        non_matches.insert( subcondition_non_matching_non_targets.begin(),  subcondition_non_matching_non_targets.end());
+        // this leaves the original contents of non_matches unchanged, other than
+        // possibly having transferred some objects into non_matches from matches
+    }
+}
+
+std::string Condition_2::SortedNumberOf::Description(bool negated/* = false*/) const
+{
+    std::string number_str = ValueRef_2::ConstantExpr(m_number) ? boost::lexical_cast<std::string>(Dump(m_number)) : Description(m_number);
+
+    if (m_sorting_method == SORT_RANDOM) {
+        std::string description_str = "DESC_NUMBER_OF";
+        if (negated)
+            description_str += "_NOT";
+        return str(FlexibleFormat(UserString(description_str))
+                   % number_str
+                   % m_condition->Description());
+    } else {
+        std::string sort_key_str = ValueRef_2::ConstantExpr(m_sort_key) ? boost::lexical_cast<std::string>(Dump(m_sort_key)) : Description(m_sort_key);
+
+        std::string description_str, temp;
+        switch (m_sorting_method) {
+        case SORT_MAX:
+            temp = "DESC_MAX_NUMBER_OF";
+            if (negated)
+                temp += "_NOT";
+            description_str = UserString(temp);
+            break;
+
+        case SORT_MIN:
+            temp = "DESC_MIN_NUMBER_OF";
+            if (negated)
+                temp += "_NOT";
+            description_str = UserString(temp);
+            break;
+
+        case SORT_MODE:
+            temp = "DESC_MODE_NUMBER_OF";
+            if (negated)
+                temp += "_NOT";
+            description_str = UserString(temp);
+            break;
+        default:
+            break;
+        }
+
+        return str(FlexibleFormat(UserString(description_str))
+                   % number_str
+                   % sort_key_str
+                   % m_condition->Description());
+    }
+}
+
+std::string Condition_2::SortedNumberOf::Dump() const
+{
+    std::string retval = DumpIndent();
+    switch (m_sorting_method) {
+    case SORT_RANDOM:
+        retval += "NumberOf";   break;
+    case SORT_MAX:
+        retval += "MaximumNumberOf";  break;
+    case SORT_MIN:
+        retval += "MinimumNumberOf"; break;
+    case SORT_MODE:
+        retval += "ModeNumberOf"; break;
+    default:
+        retval += "??NumberOf??"; break;
+    }
+
+    retval += " number = " + Dump(m_number);
+
+    if (m_sort_key)
+         retval += " sortby = " + Dump(m_sort_key);
+
+    retval += " condition =\n";
+    ++g_indent;
+        retval += m_condition->Dump();
+    --g_indent;
+
+    return retval;
+}
+
+///////////////////////////////////////////////////////////
+// All                                                   //
+///////////////////////////////////////////////////////////
+Condition_2::All::All()
+{}
+
+void Condition_2::All::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    if (search_domain == NON_MATCHES) {
+        // move all objects from non_matches to matches
+        matches.insert(non_matches.begin(), non_matches.end());
+        non_matches.clear();
+    }
+    // if search_comain is MATCHES, do nothing: all objects in matches set
+    // match this condition, so should remain in mathes set
+}
+
+std::string Condition_2::All::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_ALL";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::All::Dump() const
+{
+    return DumpIndent() + "All\n";
+}
+
+///////////////////////////////////////////////////////////
+// EmpireAffiliation                                     //
+///////////////////////////////////////////////////////////
+Condition_2::EmpireAffiliation::EmpireAffiliation(const ValueRef_2::Int& empire_id,
+                                                EmpireAffiliationType affiliation) :
+    m_empire_id(empire_id),
+    m_affiliation(affiliation)
+{}
+
+Condition_2::EmpireAffiliation::EmpireAffiliation(EmpireAffiliationType affiliation) :
+   m_empire_id(0),
+   m_affiliation(affiliation)
+{}
+
+namespace {
+    bool EmpireAffiliationSimpleMatch(const UniverseObject* candidate, int empire_id,
+                                      EmpireAffiliationType affiliation)
+    {
+        if (!candidate)
+            return false;
+
+        switch (affiliation) {
+        case AFFIL_SELF:
+            return empire_id != ALL_EMPIRES && candidate->OwnedBy(empire_id);
+            break;
+        case AFFIL_ENEMY:
+            return empire_id != ALL_EMPIRES && !candidate->Unowned() && !candidate->OwnedBy(empire_id);
+            break;
+        case AFFIL_ANY:
+            return !candidate->Unowned();
+            break;
+        default:
+            return false;
+            break;
+        }
+    }
+}
+
+void Condition_2::EmpireAffiliation::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = (!m_empire_id || ValueRef_2::ConstantExpr(m_empire_id)) ||
+                            ((!m_empire_id || LocalCandidateInvariant(m_empire_id)) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int empire_id = m_empire_id ? m_empire_id->Eval(ScriptingContext(parent_context, no_object)) : ALL_EMPIRES;
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = EmpireAffiliationSimpleMatch(*temp, empire_id, m_affiliation);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::EmpireAffiliation::RootCandidateInvariant() const
+{ return m_empire_id ? RootCandidateInvariant(m_empire_id) : true; }
+
+bool Condition_2::EmpireAffiliation::TargetInvariant() const
+{ return m_empire_id ? TargetInvariant(m_empire_id) : true; }
+
+std::string Condition_2::EmpireAffiliation::Description(bool negated/* = false*/) const
+{
+    std::string empire_str;
+    if (m_empire_id) {
+        int empire_id = ALL_EMPIRES;
+        if (ValueRef_2::ConstantExpr(m_empire_id))
+            empire_id = m_empire_id->Eval();
+        if (const Empire* empire = Empires().Lookup(empire_id))
+            empire_str = empire->Name();
+        else
+            empire_str = Description(m_empire_id);
+    }
+
+    if (m_affiliation == AFFIL_SELF) {
+        std::string description_str = "DESC_EMPIRE_AFFILIATION_SELF";
+        if (negated)
+            description_str += "_NOT";
+        return str(FlexibleFormat(UserString(description_str)) % empire_str);
+    } else if (m_affiliation == AFFIL_ANY) {
+        std::string description_str = "DESC_EMPIRE_AFFILIATION_ANY";
+        if (negated)
+            description_str += "_NOT";
+        return UserString(description_str);
+    } else {
+        std::string description_str = "DESC_EMPIRE_AFFILIATION";
+        if (negated)
+            description_str += "_NOT";
+        return str(FlexibleFormat(UserString(description_str))
+                   % UserString(boost::lexical_cast<std::string>(m_affiliation))
+                   % empire_str);
+    }
+}
+
+std::string Condition_2::EmpireAffiliation::Dump() const
+{
+    std::string retval = DumpIndent() + "OwnedBy";
+    retval += " affiliation = ";
+    switch (m_affiliation) {
+    case AFFIL_SELF:    retval += "TheEmpire";  break;
+    case AFFIL_ENEMY:   retval += "EnemyOf";    break;
+    case AFFIL_ALLY:    retval += "AllyOf";     break;
+    case AFFIL_ANY:     retval += "AnyEmpire";  break;
+    default: retval += "?"; break;
+    }
+    if (m_empire_id)
+        retval += " empire = " + Dump(m_empire_id) + "\n";
+    return retval;
+}
+
+bool Condition_2::EmpireAffiliation::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "EmpireAffiliation::Match passed no candidate object";
+        return false;
+    }
+
+    int empire_id = m_empire_id ? m_empire_id->Eval(local_context) : ALL_EMPIRES;
+
+    return EmpireAffiliationSimpleMatch(candidate, empire_id, m_affiliation);
+}
+
+///////////////////////////////////////////////////////////
+// Source                                                //
+///////////////////////////////////////////////////////////
+Condition_2::Source::Source()
+{}
+
+std::string Condition_2::Source::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_SOURCE";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::Source::Dump() const
+{
+    return DumpIndent() + "Source\n";
+}
+
+bool Condition_2::Source::Match(const ScriptingContext& local_context) const
+{
+    if (!local_context.source)
+        return false;
+    return local_context.source == local_context.condition_local_candidate;
+}
+
+///////////////////////////////////////////////////////////
+// RootCandidate                                         //
+///////////////////////////////////////////////////////////
+Condition_2::RootCandidate::RootCandidate()
+{}
+
+std::string Condition_2::RootCandidate::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_ROOT_CANDIDATE";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::RootCandidate::Dump() const
+{ return DumpIndent() + "RootCandidate\n"; }
+
+bool Condition_2::RootCandidate::Match(const ScriptingContext& local_context) const
+{
+    if (!local_context.condition_root_candidate)
+        return false;
+    return local_context.condition_root_candidate == local_context.condition_local_candidate;
+}
+
+///////////////////////////////////////////////////////////
+// Target                                                //
+///////////////////////////////////////////////////////////
+Condition_2::Target::Target()
+{}
+
+std::string Condition_2::Target::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_TARGET";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::Target::Dump() const
+{ return DumpIndent() + "Target\n"; }
+
+bool Condition_2::Target::Match(const ScriptingContext& local_context) const
+{
+    if (!local_context.effect_target)
+        return false;
+    return local_context.effect_target == local_context.condition_local_candidate;
+}
+
+///////////////////////////////////////////////////////////
+// Homeworld                                             //
+///////////////////////////////////////////////////////////
+Condition_2::Homeworld::Homeworld() :
+    m_names()
+{}
+
+Condition_2::Homeworld::Homeworld(const std::vector<ValueRef_2::String>& names) :
+    m_names(names)
+{}
+
+namespace {
+    bool HomeworldSimpleMatch(const UniverseObject* candidate, const std::vector<std::string>& names)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a planet or a building on a planet?
+        const Planet* planet = universe_object_cast<const Planet*>(candidate);
+        const ::Building* building = 0;
+        if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+            planet = objects.Object<Planet>(building->PlanetID());
+        }
+        if (!planet)
+            return false;
+
+        int planet_id = planet->ID();
+        const SpeciesManager& manager = GetSpeciesManager();
+
+        if (names.empty()) {
+            // match homeworlds for any species
+            for (SpeciesManager::iterator species_it = manager.begin(); species_it != manager.end(); ++species_it) {
+                if (const ::Species* species = species_it->second) {
+                    const std::set<int>& homeworld_ids = species->Homeworlds();
+                    if (homeworld_ids.find(planet_id) != homeworld_ids.end())
+                        return true;
+                }
+            }
+
+        } else {
+            // match any of the species specified
+            for (std::vector<std::string>::const_iterator it = names.begin(); it != names.end(); ++it) {
+                if (const ::Species* species = GetSpecies(*it)) {
+                    const std::set<int>& homeworld_ids = species->Homeworlds();
+                    if (homeworld_ids.find(planet_id) != homeworld_ids.end())
+                        return true;
+                }
+            }
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::Homeworld::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate names once, and use to check all candidate objects
+        std::vector<std::string> names;
+        // get all names from valuerefs
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            names.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = HomeworldSimpleMatch(*temp, names);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed names for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Homeworld::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::Homeworld::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::Homeworld::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_names.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_names[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_names[i]->Eval())) :
+                        Description(m_names[i]);
+        if (2 <= m_names.size() && i < m_names.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_names.size() - 2) {
+            values_str += m_names.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_HOMEWORLD";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::Homeworld::Dump() const
+{
+    std::string retval = DumpIndent() + "HomeWorld name = ";
+    if (m_names.size() == 1) {
+        retval += Dump(m_names[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_names.size(); ++i) {
+            retval += Dump(m_names[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::Homeworld::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Homeworld::Match passed no candidate object";
+        return false;
+    }
+
+    // is it a planet or a building on a planet?
+    const Planet* planet = universe_object_cast<const Planet*>(candidate);
+    const ::Building* building = 0;
+    if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+        planet = objects.Object<Planet>(building->PlanetID());
+    }
+    if (!planet)
+        return false;
+
+    int planet_id = planet->ID();
+    const SpeciesManager& manager = GetSpeciesManager();
+
+    if (m_names.empty()) {
+        // match homeworlds for any species
+        for (SpeciesManager::iterator species_it = manager.begin(); species_it != manager.end(); ++species_it) {
+            if (const ::Species* species = species_it->second) {
+                const std::set<int>& homeworld_ids = species->Homeworlds();
+                if (homeworld_ids.find(planet_id) != homeworld_ids.end())   // is this planet the homeworld for this species?
+                    return true;
+            }
+        }
+
+    } else {
+        // match any of the species specified
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            const std::string& species_name = (*it)->Eval(local_context);
+            if (const ::Species* species = manager.GetSpecies(species_name)) {
+                const std::set<int>& homeworld_ids = species->Homeworlds();
+                if (homeworld_ids.find(planet_id) != homeworld_ids.end())   // is this planet the homeworld for this species?
+                    return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// Capital                                               //
+///////////////////////////////////////////////////////////
+Condition_2::Capital::Capital()
+{}
+
+std::string Condition_2::Capital::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_CAPITAL";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::Capital::Dump() const
+{ return DumpIndent() + "Capital\n"; }
+
+bool Condition_2::Capital::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Capital::Match passed no candidate object";
+        return false;
+    }
+    int candidate_id = candidate->ID();
+
+    // check if any empire's capital's ID is that candidate object's id.
+    // if it is, the candidate object is a capital.
+    const EmpireManager& empires = Empires();
+    for (EmpireManager::const_iterator it = empires.begin(); it != empires.end(); ++it)
+        if (it->second->CapitalID() == candidate_id)
+            return true;
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// Monster                                               //
+///////////////////////////////////////////////////////////
+Condition_2::Monster::Monster()
+{}
+
+std::string Condition_2::Monster::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_MONSTER";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::Monster::Dump() const
+{ return DumpIndent() + "Monster\n"; }
+
+bool Condition_2::Monster::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Monster::Match passed no candidate object";
+        return false;
+    }
+
+    if (const Ship* ship = universe_object_cast<const Ship*>(candidate))
+        if (ship->IsMonster())
+            return true;
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// Armed                                                 //
+///////////////////////////////////////////////////////////
+Condition_2::Armed::Armed()
+{}
+
+std::string Condition_2::Armed::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_ARMED";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::Armed::Dump() const
+{ return DumpIndent() + "Armed\n"; }
+
+bool Condition_2::Armed::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Armed::Match passed no candidate object";
+        return false;
+    }
+
+    if (const Ship* ship = universe_object_cast<const Ship*>(candidate))
+        if (ship->IsArmed())
+            return true;
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// Type                                                  //
+///////////////////////////////////////////////////////////
+Condition_2::Type::Type(const ValueRef_2::UniverseObjectType& type) :
+    m_type(type)
+{}
+
+namespace {
+    bool TypeSimpleMatch(const UniverseObject* candidate, UniverseObjectType type)
+    {
+        if (!candidate)
+            return false;
+
+        switch (type) {
+        case OBJ_BUILDING:
+            return universe_object_cast<const ::Building*>(candidate);
+            break;
+        case OBJ_SHIP:
+            return universe_object_cast<const Ship*>(candidate);
+            break;
+        case OBJ_FLEET:
+            return universe_object_cast<const Fleet*>(candidate);
+            break;
+        case OBJ_PLANET:
+            return universe_object_cast<const Planet*>(candidate);
+            break;
+        case OBJ_POP_CENTER:
+            return dynamic_cast<const PopCenter*>(candidate);
+            break;
+        case OBJ_PROD_CENTER:
+            return dynamic_cast<const ResourceCenter*>(candidate);
+            break;
+        case OBJ_SYSTEM:
+            return universe_object_cast<const System*>(candidate);
+            break;
+        default:
+            break;
+        }
+        return false;
+    }
+}
+
+void Condition_2::Type::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_type) ||
+                            (LocalCandidateInvariant(m_type) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        UniverseObjectType type = m_type->Eval(parent_context);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = TypeSimpleMatch(*temp, type);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Type::RootCandidateInvariant() const
+{
+    return RootCandidateInvariant(m_type);
+}
+
+bool Condition_2::Type::TargetInvariant() const
+{
+    return TargetInvariant(m_type);
+}
+
+std::string Condition_2::Type::Description(bool negated/* = false*/) const
+{
+    std::string value_str = ValueRef_2::ConstantExpr(m_type) ?
+                                UserString(boost::lexical_cast<std::string>(m_type->Eval())) :
+                                Description(m_type);
+    std::string description_str = "DESC_TYPE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % value_str);
+}
+
+std::string Condition_2::Type::Dump() const
+{
+    std::string retval = DumpIndent();
+    if (dynamic_cast<const ValueRef_2::Constant<UniverseObjectType>*>(m_type)) {
+        switch (m_type->Eval()) {
+        case OBJ_BUILDING:    retval += "Building\n"; break;
+        case OBJ_SHIP:        retval += "Ship\n"; break;
+        case OBJ_FLEET:       retval += "Fleet\n"; break;
+        case OBJ_PLANET:      retval += "Planet\n"; break;
+        case OBJ_POP_CENTER:  retval += "PopulationCenter\n"; break;
+        case OBJ_PROD_CENTER: retval += "ProductionCenter\n"; break;
+        case OBJ_SYSTEM:      retval += "System\n"; break;
+        default: retval += "?\n"; break;
+        }
+    } else {
+        retval += "ObjectType type = " + Dump(m_type) + "\n";
+    }
+    return retval;
+}
+
+bool Condition_2::Type::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Type::Match passed no candidate object";
+        return false;
+    }
+
+    return TypeSimpleMatch(candidate, m_type->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// Building                                              //
+///////////////////////////////////////////////////////////
+Condition_2::Building::Building(const std::vector<ValueRef_2::String>& names) :
+    m_names(names)
+{}
+
+namespace {
+    bool BuildingSimpleMatch(const UniverseObject* candidate, const std::vector<std::string>& names)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a building?
+        const ::Building* building = universe_object_cast<const ::Building*>(candidate);
+        if (!building)
+            return false;
+
+        // if no name supplied, match any building
+        if (names.empty())
+            return true;
+
+        // is it one of the specified building types?
+        return std::find(names.begin(), names.end(), building->BuildingTypeName()) != names.end();
+    }
+}
+
+void Condition_2::Building::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate names once, and use to check all candidate objects
+        std::vector<std::string> names;
+        // get all names from valuerefs
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            names.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = BuildingSimpleMatch(*temp, names);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed building types range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Building::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::Building::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::Building::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_names.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_names[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_names[i]->Eval())) :
+                        Description(m_names[i]);
+        if (2 <= m_names.size() && i < m_names.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_names.size() - 2) {
+            values_str += m_names.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_BUILDING";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::Building::Dump() const
+{
+    std::string retval = DumpIndent() + "Building name = ";
+    if (m_names.size() == 1) {
+        retval += Dump(m_names[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_names.size(); ++i) {
+            retval += Dump(m_names[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::Building::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Building::Match passed no candidate object";
+        return false;
+    }
+
+    // is it a building?
+    const ::Building* building = universe_object_cast<const ::Building*>(candidate);
+    if (building) {
+        // match any building type?
+        if (m_names.empty())
+            return true;
+
+        // match one of the specified building types
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            if ((*it)->Eval(local_context) == building->BuildingTypeName())
+                return true;
+        }
+    }
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// HasSpecial                                            //
+///////////////////////////////////////////////////////////
+Condition_2::HasSpecial::HasSpecial(const std::string& name) :
+    m_name(name),
+    m_since_turn_low(0),
+    m_since_turn_high(0)
+{}
+
+Condition_2::HasSpecial::HasSpecial(const std::string& name,
+                                  const ValueRef_2::Int& since_turn_low,
+                                  const ValueRef_2::Int& since_turn_high) :
+    m_name(name),
+    m_since_turn_low(since_turn_low),
+    m_since_turn_high(since_turn_high)
+{}
+
+namespace {
+    bool HasSpecialSimpleMatch(const UniverseObject* candidate, const std::string& name,
+                               int low_turn, int high_turn)
+    {
+        if (!candidate)
+            return false;
+
+        if (name.empty())
+            return !candidate->Specials().empty();
+
+        std::map<std::string, int>::const_iterator it = candidate->Specials().find(name);
+        if (it == candidate->Specials().end())
+            return false;
+
+        int special_since_turn = it->second;
+
+        return low_turn <= special_since_turn && special_since_turn < high_turn;
+    }
+}
+
+void Condition_2::HasSpecial::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ((!m_since_turn_low || LocalCandidateInvariant(m_since_turn_low)) &&
+                             (!m_since_turn_high || LocalCandidateInvariant(m_since_turn_high)) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate turn limits once, pass to simple match for all candidates
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        int low = (m_since_turn_low ? m_since_turn_low->Eval(local_context) : BEFORE_FIRST_TURN);
+        int high = (m_since_turn_high ? m_since_turn_high->Eval(local_context) : IMPOSSIBLY_LARGE_TURN);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = HasSpecialSimpleMatch(*temp, m_name, low, high);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::HasSpecial::RootCandidateInvariant() const
+{ return ((!m_since_turn_low || RootCandidateInvariant(m_since_turn_low)) &&
+          (!m_since_turn_high || RootCandidateInvariant(m_since_turn_high))); }
+
+bool Condition_2::HasSpecial::TargetInvariant() const
+{ return ((!m_since_turn_low || TargetInvariant(m_since_turn_low)) &&
+          (!m_since_turn_high || TargetInvariant(m_since_turn_high))); }
+
+std::string Condition_2::HasSpecial::Description(bool negated/* = false*/) const
+{
+    if (!m_since_turn_low && !m_since_turn_high) {
+        std::string description_str = "DESC_SPECIAL";
+        if (negated)
+            description_str += "_NOT";
+        return str(FlexibleFormat(UserString(description_str))
+                   % UserString(m_name));
+    }
+
+    // turn ranges have been specified; must indicate in description
+    std::string low_str = boost::lexical_cast<std::string>(BEFORE_FIRST_TURN);
+    if (m_since_turn_low) {
+        low_str = ValueRef_2::ConstantExpr(m_since_turn_low) ?
+                  boost::lexical_cast<std::string>(m_since_turn_low->Eval()) :
+                  Description(m_since_turn_low);
+    }
+    std::string high_str = boost::lexical_cast<std::string>(IMPOSSIBLY_LARGE_TURN);
+    if (m_since_turn_high) {
+        high_str = ValueRef_2::ConstantExpr(m_since_turn_high) ?
+                   boost::lexical_cast<std::string>(m_since_turn_high->Eval()) :
+                   Description(m_since_turn_high);
+    }
+
+    std::string description_str = "DESC_SPECIAL_TURN_RANGE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % UserString(m_name)
+               % low_str
+               % high_str);
+}
+
+std::string Condition_2::HasSpecial::Dump() const
+{
+    if (!m_since_turn_low && !m_since_turn_high)
+        return DumpIndent() + "HasSpecial name = \"" + m_name + "\"\n";
+
+    std::string low_dump = (m_since_turn_low ? Dump(m_since_turn_low) : boost::lexical_cast<std::string>(BEFORE_FIRST_TURN));
+    std::string high_dump = (m_since_turn_high ? Dump(m_since_turn_high) : boost::lexical_cast<std::string>(IMPOSSIBLY_LARGE_TURN));
+    return DumpIndent() + "HasSpecial name = \"" + m_name + "\" low = " + low_dump + " high = " + high_dump;
+}
+
+bool Condition_2::HasSpecial::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "HasSpecial::Match passed no candidate object";
+        return false;
+    }
+    int low = (m_since_turn_low ? m_since_turn_low->Eval(local_context) : BEFORE_FIRST_TURN);
+    int high = (m_since_turn_high ? m_since_turn_high->Eval(local_context) : IMPOSSIBLY_LARGE_TURN);
+    return HasSpecialSimpleMatch(candidate, m_name, low, high);
+}
+
+///////////////////////////////////////////////////////////
+// CreatedOnTurn                                         //
+///////////////////////////////////////////////////////////
+Condition_2::CreatedOnTurn::CreatedOnTurn(const ValueRef_2::Int& low,
+                                        const ValueRef_2::Int& high) :
+    m_low(low),
+    m_high(high)
+{}
+
+namespace {
+    bool CreatedOnTurnSimpleMatch(const UniverseObject* candidate, int low, int high)
+    {
+        return candidate &&
+               low <= candidate->CreationTurn() &&
+               candidate->CreationTurn() < high;
+    }
+}
+
+void Condition_2::CreatedOnTurn::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ((!m_low || LocalCandidateInvariant(m_low)) &&
+                             (!m_high || LocalCandidateInvariant(m_high)) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        int low = (m_low ? m_low->Eval(local_context) : BEFORE_FIRST_TURN);
+        int high = (m_high ? m_high->Eval(local_context) : IMPOSSIBLY_LARGE_TURN);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = CreatedOnTurnSimpleMatch(*temp, low, high);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::CreatedOnTurn::RootCandidateInvariant() const
+{ return (RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high)); }
+
+bool Condition_2::CreatedOnTurn::TargetInvariant() const
+{ return (TargetInvariant(m_low) && TargetInvariant(m_high)); }
+
+std::string Condition_2::CreatedOnTurn::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                            boost::lexical_cast<std::string>(m_high->Eval()) :
+                            Description(m_high);
+    std::string description_str = "DESC_CREATED_ON_TURN";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % low_str
+               % high_str);
+}
+
+std::string Condition_2::CreatedOnTurn::Dump() const
+{ return DumpIndent() + "CreatedOnTurn low = " + Dump(m_low) + " high = " + Dump(m_high) + "\n"; }
+
+bool Condition_2::CreatedOnTurn::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "CreatedOnTurn::Match passed no candidate object";
+        return false;
+    }
+
+    double low = std::max(0, m_low->Eval(local_context));
+    double high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+
+    return CreatedOnTurnSimpleMatch(candidate, low, high);
+}
+
+///////////////////////////////////////////////////////////
+// Contains                                              //
+///////////////////////////////////////////////////////////
+Condition_2::Contains::Contains(const ConditionBase* condition) :
+    m_condition(condition)
+{}
+
+Condition_2::Contains::~Contains()
+{ delete m_condition; }
+
+void Condition_2::Contains::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // evaluate contained objects once and check for all candidates
+        ObjectMap& objects = GetUniverse().Objects();
+
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+
+        // get objects to be considering for matching against subcondition
+        ObjectSet subcondition_non_matches;
+        for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+            subcondition_non_matches.insert(it->second);
+        ObjectSet subcondition_matches;
+
+        m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            // does candidate object contain any subcondition matches?
+            bool match = false;
+            // does candidate object contain any subcondition matches?
+            for (ObjectSet::iterator subcon_it = subcondition_matches.begin(); subcon_it != subcondition_matches.end(); ++subcon_it) {
+                if ((*temp)->Contains((*subcon_it)->ID())) {
+                    match = true;
+                    break;
+                }
+            }
+            // transfer
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Contains::RootCandidateInvariant() const
+{ return m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::Contains::TargetInvariant() const
+{ return m_condition->TargetInvariant(); }
+
+std::string Condition_2::Contains::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_CONTAINS";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % m_condition->Description());
+}
+
+std::string Condition_2::Contains::Dump() const
+{
+    std::string retval = DumpIndent() + "Contains condition =\n";
+    ++g_indent;
+    retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+bool Condition_2::Contains::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Contains::Match passed no candidate object";
+        return false;
+    }
+
+    ObjectMap& objects = GetUniverse().Objects();
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+    // does candidate object contain any subcondition matches?
+    for (ObjectSet::iterator subcon_it = subcondition_matches.begin(); subcon_it != subcondition_matches.end(); ++subcon_it)
+        if (candidate->Contains((*subcon_it)->ID()))
+            return true;
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// ContainedBy                                           //
+///////////////////////////////////////////////////////////
+Condition_2::ContainedBy::ContainedBy(const ConditionBase* condition) :
+    m_condition(condition)
+{}
+
+Condition_2::ContainedBy::~ContainedBy()
+{ delete m_condition; }
+
+void Condition_2::ContainedBy::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // evaluate contained objects once and check for all candidates
+        ObjectMap& objects = GetUniverse().Objects();
+
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+
+        // get objects to be considering for matching against subcondition
+        ObjectSet subcondition_non_matches;
+        for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+            subcondition_non_matches.insert(it->second);
+        ObjectSet subcondition_matches;
+
+        m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            // is candidate object contained by any subcondition matches?
+            bool match = false;
+            for (ObjectSet::iterator subcon_it = subcondition_matches.begin(); subcon_it != subcondition_matches.end(); ++subcon_it) {
+                if ((*subcon_it)->Contains((*temp)->ID())) {
+                    match = true;
+                    break;
+                }
+            }
+            // transfer
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::ContainedBy::RootCandidateInvariant() const
+{ return m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::ContainedBy::TargetInvariant() const
+{ return m_condition->TargetInvariant(); }
+
+std::string Condition_2::ContainedBy::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_CONTAINED_BY";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % m_condition->Description());
+}
+
+std::string Condition_2::ContainedBy::Dump() const
+{
+    std::string retval = DumpIndent() + "ContainedBy condition =\n";
+    ++g_indent;
+        retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+bool Condition_2::ContainedBy::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "ContainedBy::Match passed no candidate object";
+        return false;
+    }
+
+    ObjectMap& objects = GetUniverse().Objects();
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+    // is candidate object contained by any subcondition matches?
+    for (ObjectSet::iterator subcon_it = subcondition_matches.begin(); subcon_it != subcondition_matches.end(); ++subcon_it)
+        if ((*subcon_it)->Contains(candidate->ID()))
+            return true;
+
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// InSystem                                              //
+///////////////////////////////////////////////////////////
+Condition_2::InSystem::InSystem(const ValueRef_2::Int& system_id) :
+    m_system_id(system_id)
+{}
+
+namespace {
+    bool InSystemSimpleMatch(const UniverseObject* candidate, int system_id)
+    {
+        // don't match objects not in systems
+        return candidate &&
+               system_id != UniverseObject::INVALID_OBJECT_ID &&
+               candidate->SystemID() == system_id;
+    }
+}
+
+void Condition_2::InSystem::Eval(const ScriptingContext& parent_context, ObjectSet& matches,
+                               ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_system_id) ||
+                            (LocalCandidateInvariant(m_system_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int system_id = m_system_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = InSystemSimpleMatch(*temp, system_id);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::InSystem::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_system_id); }
+
+bool Condition_2::InSystem::TargetInvariant() const
+{ return TargetInvariant(m_system_id); }
+
+std::string Condition_2::InSystem::Description(bool negated/* = false*/) const
+{
+    const ObjectMap& objects = GetUniverse().Objects();
+
+    std::string system_str;
+    int system_id = UniverseObject::INVALID_OBJECT_ID;
+    if (ValueRef_2::ConstantExpr(m_system_id))
+        system_id = m_system_id->Eval();
+    if (const System* system = objects.Object<System>(system_id))
+        system_str = system->Name();
+    else
+        system_str = Description(m_system_id);
+
+    std::string description_str = "DESC_IN_SYSTEM";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % system_str);
+}
+
+std::string Condition_2::InSystem::Dump() const
+{ return DumpIndent() + "InSystem system_id = " + Dump(m_system_id); }
+
+bool Condition_2::InSystem::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "InSystem::Match passed no candidate object";
+        return false;
+    }
+
+    return InSystemSimpleMatch(candidate, m_system_id->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// ObjectID                                              //
+///////////////////////////////////////////////////////////
+Condition_2::ObjectID::ObjectID(const ValueRef_2::Int& object_id) :
+    m_object_id(object_id)
+{}
+
+namespace {
+    bool ObjectIDSimpleMatch(const UniverseObject* candidate, int object_id)
+    {
+        return candidate &&
+               object_id != UniverseObject::INVALID_OBJECT_ID &&
+               candidate->ID() == object_id;
+    }
+}
+
+void Condition_2::ObjectID::Eval(const ScriptingContext& parent_context, ObjectSet& matches,
+                               ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_object_id) ||
+                            (LocalCandidateInvariant(m_object_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int object_id = m_object_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = ObjectIDSimpleMatch(*temp, object_id);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::ObjectID::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_object_id); }
+
+bool Condition_2::ObjectID::TargetInvariant() const
+{ return TargetInvariant(m_object_id); }
+
+std::string Condition_2::ObjectID::Description(bool negated/* = false*/) const
+{
+    const ObjectMap& objects = GetUniverse().Objects();
+
+    std::string object_str;
+    int object_id = UniverseObject::INVALID_OBJECT_ID;
+    if (ValueRef_2::ConstantExpr(m_object_id))
+        object_id = m_object_id->Eval();
+    if (const System* system = objects.Object<System>(object_id))
+        object_str = system->Name();
+    else
+        object_str = Description(m_object_id);
+
+    std::string description_str = "DESC_OBJECT_ID";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % object_str);
+}
+
+std::string Condition_2::ObjectID::Dump() const
+{ return DumpIndent() + "Object id = " + Dump(m_object_id); }
+
+bool Condition_2::ObjectID::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "ObjectID::Match passed no candidate object";
+        return false;
+    }
+
+    return ObjectIDSimpleMatch(candidate, m_object_id->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// PlanetType                                            //
+///////////////////////////////////////////////////////////
+Condition_2::PlanetType::PlanetType(const std::vector<ValueRef_2::PlanetType>& types) :
+    m_types(types){}
+
+namespace {
+    bool PlanetTypeSimpleMatch(const UniverseObject* candidate, const std::vector< ::PlanetType>& types)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a planet or on a planet?
+        const Planet* planet = universe_object_cast<const Planet*>(candidate);
+        const ::Building* building = 0;
+        if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+            planet = objects.Object<Planet>(building->PlanetID());
+        }
+        if (planet) {
+            // is it one of the specified building types?
+            return std::find(types.begin(), types.end(), planet->Type()) != types.end();
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::PlanetType::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::PlanetType>::const_iterator it = m_types.begin();
+            it != m_types.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate types once, and use to check all candidate objects
+        std::vector< ::PlanetType> types;
+        // get all types from valuerefs
+        for (std::vector<ValueRef_2::PlanetType>::const_iterator it = m_types.begin();
+             it != m_types.end(); ++it)
+        {
+            types.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = PlanetTypeSimpleMatch(*temp, types);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::PlanetType::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::PlanetType>::const_iterator it = m_types.begin();
+         it != m_types.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::PlanetType::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::PlanetType>::const_iterator it = m_types.begin();
+         it != m_types.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::PlanetType::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_types.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_types[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_types[i]->Eval())) :
+                        Description(m_types[i]);
+        if (2 <= m_types.size() && i < m_types.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_types.size() - 2) {
+            values_str += m_types.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_PLANET_TYPE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::PlanetType::Dump() const
+{
+    std::string retval = DumpIndent() + "Planet type = ";
+    if (m_types.size() == 1) {
+        retval += Dump(m_types[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_types.size(); ++i) {
+            retval += Dump(m_types[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::PlanetType::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "PlanetType::Match passed no candidate object";
+        return false;
+    }
+
+    const Planet* planet = universe_object_cast<const Planet*>(candidate);
+    const ::Building* building = 0;
+    if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+        planet = objects.Object<Planet>(building->PlanetID());
+    }
+    if (planet) {
+        for (std::vector<ValueRef_2::PlanetType>::const_iterator it = m_types.begin();
+             it != m_types.end(); ++it)
+        {
+            if ((*it)->Eval(ScriptingContext(local_context)) == planet->Type())
+                return true;
+        }
+    }
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// PlanetSize                                            //
+///////////////////////////////////////////////////////////
+Condition_2::PlanetSize::PlanetSize(const std::vector<ValueRef_2::PlanetSize>& sizes) :
+    m_sizes(sizes)
+{}
+
+namespace {
+    bool PlanetSizeSimpleMatch(const UniverseObject* candidate, const std::vector< ::PlanetSize>& sizes)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a planet or on a planet?
+        const Planet* planet = universe_object_cast<const Planet*>(candidate);
+        const ::Building* building = 0;
+        if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+            planet = objects.Object<Planet>(building->PlanetID());
+        }
+        if (planet) {
+            // is it one of the specified building types?
+            for (std::vector< ::PlanetSize>::const_iterator it = sizes.begin();
+                 it != sizes.end(); ++it)
+            {
+                if (planet->Size() == *it)
+                    return true;
+            }
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::PlanetSize::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::PlanetSize>::const_iterator it = m_sizes.begin();
+            it != m_sizes.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate types once, and use to check all candidate objects
+        std::vector< ::PlanetSize> sizes;
+        // get all types from valuerefs
+        for (std::vector<ValueRef_2::PlanetSize>::const_iterator it = m_sizes.begin();
+             it != m_sizes.end(); ++it)
+        {
+            sizes.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = PlanetSizeSimpleMatch(*temp, sizes);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::PlanetSize::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::PlanetSize>::const_iterator it = m_sizes.begin();
+         it != m_sizes.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::PlanetSize::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::PlanetSize>::const_iterator it = m_sizes.begin();
+         it != m_sizes.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::PlanetSize::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_sizes.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_sizes[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_sizes[i]->Eval())) :
+                        Description(m_sizes[i]);
+        if (2 <= m_sizes.size() && i < m_sizes.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_sizes.size() - 2) {
+            values_str += m_sizes.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_PLANET_SIZE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::PlanetSize::Dump() const
+{
+    std::string retval = DumpIndent() + "Planet size = ";
+    if (m_sizes.size() == 1) {
+        retval += Dump(m_sizes[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_sizes.size(); ++i) {
+            retval += Dump(m_sizes[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::PlanetSize::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "PlanetSize::Match passed no candidate object";
+        return false;
+    }
+
+    const Planet* planet = universe_object_cast<const Planet*>(candidate);
+    const ::Building* building = 0;
+    if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+        planet = objects.Object<Planet>(building->PlanetID());
+    }
+    if (planet) {
+        for (unsigned int i = 0; i < m_sizes.size(); ++i) {
+            if (m_sizes[i]->Eval(local_context) == planet->Size())
+                return true;
+        }
+    }
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// PlanetEnvironment                                     //
+///////////////////////////////////////////////////////////
+Condition_2::PlanetEnvironment::PlanetEnvironment(const std::vector<ValueRef_2::PlanetEnvironment>& environments) :
+    m_environments(environments)
+{}
+
+namespace {
+    bool PlanetEnvironmentSimpleMatch(const UniverseObject* candidate, const std::vector< ::PlanetEnvironment>& environments)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a planet or on a planet?
+        const Planet* planet = universe_object_cast<const Planet*>(candidate);
+        const ::Building* building = 0;
+        if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+            planet = objects.Object<Planet>(building->PlanetID());
+        }
+        if (planet) {
+            // is it one of the specified building types?
+            for (std::vector< ::PlanetEnvironment>::const_iterator it = environments.begin();
+                 it != environments.end(); ++it)
+            {
+                if (planet->EnvironmentForSpecies() == *it)
+                    return true;
+            }
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::PlanetEnvironment::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::PlanetEnvironment>::const_iterator it = m_environments.begin();
+             it != m_environments.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate types once, and use to check all candidate objects
+        std::vector< ::PlanetEnvironment> environments;
+        // get all types from valuerefs
+        for (std::vector<ValueRef_2::PlanetEnvironment>::const_iterator it = m_environments.begin();
+             it != m_environments.end(); ++it)
+        {
+            environments.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = PlanetEnvironmentSimpleMatch(*temp, environments);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::PlanetEnvironment::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::PlanetEnvironment>::const_iterator it = m_environments.begin();
+         it != m_environments.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::PlanetEnvironment::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::PlanetEnvironment>::const_iterator it = m_environments.begin();
+         it != m_environments.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::PlanetEnvironment::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_environments.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_environments[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_environments[i]->Eval())) :
+                        Description(m_environments[i]);
+        if (2 <= m_environments.size() && i < m_environments.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_environments.size() - 2) {
+            values_str += m_environments.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_PLANET_ENVIRONMENT";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::PlanetEnvironment::Dump() const
+{
+    std::string retval = DumpIndent() + "Planet environment = ";
+    if (m_environments.size() == 1) {
+        retval += Dump(m_environments[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_environments.size(); ++i) {
+            retval += Dump(m_environments[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::PlanetEnvironment::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "PlanetEnvironment::Match passed no candidate object";
+        return false;
+    }
+
+    const Planet* planet = universe_object_cast<const Planet*>(candidate);
+    const ::Building* building = 0;
+    if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+        planet = objects.Object<Planet>(building->PlanetID());
+    }
+    if (planet) {
+        ::PlanetEnvironment env_for_planets_species = planet->EnvironmentForSpecies();
+        for (unsigned int i = 0; i < m_environments.size(); ++i) {
+            if (m_environments[i]->Eval(local_context) == env_for_planets_species)
+                return true;
+        }
+    }
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// Species                                              //
+///////////////////////////////////////////////////////////
+Condition_2::Species::Species(const std::vector<ValueRef_2::String>& names) :
+    m_names(names)
+{}
+
+Condition_2::Species::Species() :
+    m_names()
+{}
+
+namespace {
+    bool SpeciesSimpleMatch(const UniverseObject* candidate, const std::vector<std::string>& names)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a population centre?
+        if (const ::PopCenter* pop = dynamic_cast<const ::PopCenter*>(candidate)) {
+            const std::string& species_name = pop->SpeciesName();
+            // if the popcenter has a species and that species is one of those specified...
+            return !species_name.empty() && (names.empty() || (std::find(names.begin(), names.end(), species_name) != names.end()));
+        }
+        // is it a ship?
+        if (const ::Ship* ship = universe_object_cast<const ::Ship*>(candidate)) {
+            // if the ship has a species and that species is one of those specified...
+            const std::string& species_name = ship->SpeciesName();
+            return !species_name.empty() && (names.empty() || (std::find(names.begin(), names.end(), species_name) != names.end()));
+        }
+        // is it a building on a planet?
+        if (const ::Building* building = universe_object_cast<const ::Building*>(candidate)) {
+            const ::Planet* planet = objects.Object<Planet>(building->PlanetID());
+            const std::string& species_name = planet->SpeciesName();
+            // if the planet (which IS a popcenter) has a species and that species is one of those specified...
+            return !species_name.empty() && (names.empty() || (std::find(names.begin(), names.end(), species_name) != names.end()));
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::Species::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate names once, and use to check all candidate objects
+        std::vector<std::string> names;
+        // get all names from valuerefs
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            names.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = SpeciesSimpleMatch(*temp, names);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed building types range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Species::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::Species::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::Species::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_names.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_names[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_names[i]->Eval())) :
+                        Description(m_names[i]);
+        if (2 <= m_names.size() && i < m_names.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_names.size() - 2) {
+            values_str += m_names.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_SPECIES";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::Species::Dump() const
+{
+    std::string retval = DumpIndent() + "Species";
+    if (m_names.empty()) {
+        // do nothing else
+    } else if (m_names.size() == 1) {
+        retval += " name = " + Dump(m_names[0]) + "\n";
+    } else {
+        retval += " name = [ ";
+        for (unsigned int i = 0; i < m_names.size(); ++i) {
+            retval += Dump(m_names[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::Species::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Species::Match passed no candidate object";
+        return false;
+    }
+
+    // is it a planet or a building on a planet?
+    const Planet* planet = universe_object_cast<const Planet*>(candidate);
+    const ::Building* building = 0;
+    if (!planet && (building = universe_object_cast<const ::Building*>(candidate))) {
+        planet = objects.Object<Planet>(building->PlanetID());
+    }
+    if (planet) {
+        if (m_names.empty()) {
+            return !planet->SpeciesName().empty();  // match any species name
+        } else {
+            // match only specified species names
+            for (unsigned int i = 0; i < m_names.size(); ++i)
+                if (m_names[i]->Eval(local_context) == planet->SpeciesName())
+                    return true;
+        }
+    }
+    // is it a ship?
+    const Ship* ship = universe_object_cast<const Ship*>(candidate);
+    if (ship) {
+        if (m_names.empty()) {
+            return !ship->SpeciesName().empty();    // match any species name
+        } else {
+            // match only specified species names
+            for (unsigned int i = 0; i < m_names.size(); ++i)
+                if (m_names[i]->Eval(local_context) == ship->SpeciesName())
+                    return true;
+        }
+    }
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// FocusType                                             //
+///////////////////////////////////////////////////////////
+Condition_2::FocusType::FocusType(const std::vector<ValueRef_2::String>& names) :
+    m_names(names)
+{}
+
+namespace {
+    bool FocusTypeSimpleMatch(const UniverseObject* candidate, const std::vector<std::string>& names)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        // is it a ResourceCenter or a Building on a Planet (that is a ResourceCenter)
+        const ResourceCenter* res_center = dynamic_cast<const ResourceCenter*>(candidate);
+        const ::Building* building = 0;
+        if (!res_center && (building = universe_object_cast<const ::Building*>(candidate))) {
+            if (const Planet* planet = objects.Object<Planet>(building->PlanetID()))
+                res_center = dynamic_cast<const ResourceCenter*>(planet);
+        }
+        if (res_center) {
+            return !res_center->Focus().empty() && (std::find(names.begin(), names.end(), res_center->Focus()) != names.end());
+
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::FocusType::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate names once, and use to check all candidate objects
+        std::vector<std::string> names;
+        // get all names from valuerefs
+        for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+             it != m_names.end(); ++it)
+        {
+            names.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = FocusTypeSimpleMatch(*temp, names);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed building types range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::FocusType::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::FocusType::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::String>::const_iterator it = m_names.begin();
+         it != m_names.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::FocusType::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_names.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_names[i]) ?
+            UserString(boost::lexical_cast<std::string>(m_names[i]->Eval())) :
+            Description(m_names[i]);
+        if (2 <= m_names.size() && i < m_names.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_names.size() - 2) {
+            values_str += m_names.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_FOCUS_TYPE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::FocusType::Dump() const
+{
+    std::string retval = DumpIndent() + "Focus name = ";
+    if (m_names.size() == 1) {
+        retval += Dump(m_names[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_names.size(); ++i) {
+            retval += Dump(m_names[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::FocusType::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "FocusType::Match passed no candidate object";
+        return false;
+    }
+
+    // is it a ResourceCenter or a Building on a Planet (that is a ResourceCenter)
+    const ResourceCenter* res_center = dynamic_cast<const ResourceCenter*>(candidate);
+    const ::Building* building = 0;
+    if (!res_center && (building = universe_object_cast<const ::Building*>(candidate))) {
+        if (const Planet* planet = objects.Object<Planet>(building->PlanetID()))
+            res_center = dynamic_cast<const ResourceCenter*>(planet);
+    }
+    if (res_center) {
+        for (unsigned int i = 0; i < m_names.size(); ++i) {
+            if (m_names[i]->Eval(local_context) == res_center->Focus())
+                return true;
+        }
+    }
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// StarType                                              //
+///////////////////////////////////////////////////////////
+Condition_2::StarType::StarType(const std::vector<ValueRef_2::StarType>& types) :
+    m_types(types)
+{}
+
+namespace {
+    bool StarTypeSimpleMatch(const UniverseObject* candidate, const std::vector< ::StarType>& types)
+    {
+        if (!candidate)
+            return false;
+
+        const ObjectMap& objects = GetMainObjectMap();
+
+        const System* system = objects.Object<System>(candidate->SystemID());
+        if (system || (system = universe_object_cast<const System*>(candidate)))
+            return !types.empty() && (std::find(types.begin(), types.end(), system->GetStarType()) != types.end());
+
+        return false;
+    }
+}
+
+void Condition_2::StarType::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // check each valueref for invariance to local candidate
+        for (std::vector<ValueRef_2::StarType>::const_iterator it = m_types.begin();
+            it != m_types.end(); ++it)
+        {
+            if (!LocalCandidateInvariant(*it)) {
+                simple_eval_safe = false;
+                break;
+            }
+        }
+    }
+    if (simple_eval_safe) {
+        // evaluate types once, and use to check all candidate objects
+        std::vector< ::StarType> types;
+        // get all types from valuerefs
+        for (std::vector<ValueRef_2::StarType>::const_iterator it = m_types.begin();
+             it != m_types.end(); ++it)
+        {
+            types.push_back((*it)->Eval(parent_context));
+        }
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = StarTypeSimpleMatch(*temp, types);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::StarType::RootCandidateInvariant() const
+{
+    for (std::vector<ValueRef_2::StarType>::const_iterator it = m_types.begin();
+         it != m_types.end(); ++it)
+    {
+        if (!RootCandidateInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+bool Condition_2::StarType::TargetInvariant() const
+{
+    for (std::vector<ValueRef_2::StarType>::const_iterator it = m_types.begin();
+         it != m_types.end(); ++it)
+    {
+        if (!TargetInvariant(*it))
+            return false;
+    }
+    return true;
+}
+
+std::string Condition_2::StarType::Description(bool negated/* = false*/) const
+{
+    std::string values_str;
+    for (unsigned int i = 0; i < m_types.size(); ++i) {
+        values_str += ValueRef_2::ConstantExpr(m_types[i]) ?
+                        UserString(boost::lexical_cast<std::string>(m_types[i]->Eval())) :
+                        Description(m_types[i]);
+        if (2 <= m_types.size() && i < m_types.size() - 2) {
+            values_str += ", ";
+        } else if (i == m_types.size() - 2) {
+            values_str += m_types.size() < 3 ? " " : ", ";
+            values_str += UserString("OR");
+            values_str += " ";
+        }
+    }
+    std::string description_str = "DESC_STAR_TYPE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % values_str);
+}
+
+std::string Condition_2::StarType::Dump() const
+{
+    std::string retval = DumpIndent() + "Star type = ";
+    if (m_types.size() == 1) {
+        retval += Dump(m_types[0]) + "\n";
+    } else {
+        retval += "[ ";
+        for (unsigned int i = 0; i < m_types.size(); ++i) {
+            retval += Dump(m_types[i]) + " ";
+        }
+        retval += "]\n";
+    }
+    return retval;
+}
+
+bool Condition_2::StarType::Match(const ScriptingContext& local_context) const
+{
+    const ObjectMap& objects = GetMainObjectMap();
+
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "StarType::Match passed no candidate object";
+        return false;
+    }
+
+    const System* system = objects.Object<System>(candidate->SystemID());
+    if (system || (system = universe_object_cast<const System*>(candidate))) {
+        for (unsigned int i = 0; i < m_types.size(); ++i) {
+            if (m_types[i]->Eval(local_context) == system->GetStarType())
+                return true;
+        }
+    }
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// DesignHasHull                                         //
+///////////////////////////////////////////////////////////
+Condition_2::DesignHasHull::DesignHasHull(const std::string& name) :
+    m_name(name)
+{}
+
+std::string Condition_2::DesignHasHull::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_DESIGN_HAS_HULL";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % UserString(m_name));
+}
+
+std::string Condition_2::DesignHasHull::Dump() const
+{
+    return DumpIndent() + "DesignHasHull name = \"" + m_name + "\"\n";
+}
+
+bool Condition_2::DesignHasHull::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "DesignHasHull::Match passed no candidate object";
+        return false;
+    }
+
+    if (const Ship* ship = universe_object_cast<const Ship*>(candidate))
+        if (const ShipDesign* design = ship->Design())
+            return (design->Hull() == m_name);
+    return false;
+}
+
+///////////////////////////////////////////////////////////
+// DesignHasPart                                         //
+///////////////////////////////////////////////////////////
+Condition_2::DesignHasPart::DesignHasPart(const ValueRef_2::Int& low, const ValueRef_2::Int& high, const std::string& name) :
+    m_low(low),
+    m_high(high),
+    m_name(name)
+{}
+
+namespace {
+    bool DesignHasPartSimpleMatch(const UniverseObject* candidate, int low, int high, const std::string& name)
+    {
+        if (!candidate)
+            return false;
+
+        // is it a ship?
+        const ::Ship* ship = universe_object_cast<const ::Ship*>(candidate);
+        if (!ship)
+            return false;
+        // with a valid design?
+        const ShipDesign* design = ship->Design();
+        if (!design)
+            return false;
+
+        const std::vector<std::string>& parts = design->Parts();
+        int count = 0;
+        for (std::vector<std::string>::const_iterator it = parts.begin(); it != parts.end(); ++it)
+            if (*it == name || (name.empty() && !(*it).empty()))    // # of copies of specified part, or total number of parts if no part name specified
+                ++count;
+        return (low <= count && count < high);
+    }
+}
+
+void Condition_2::DesignHasPart::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = (LocalCandidateInvariant(m_low) && LocalCandidateInvariant(m_high) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate number limits once, use to match all candidates
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        int low =  std::max(0, m_low->Eval(local_context));
+        int high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = DesignHasPartSimpleMatch(*temp, low, high, m_name);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::DesignHasPart::RootCandidateInvariant() const
+{ return (RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high)); }
+
+bool Condition_2::DesignHasPart::TargetInvariant() const
+{ return (TargetInvariant(m_low) && TargetInvariant(m_high)); }
+
+std::string Condition_2::DesignHasPart::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                            boost::lexical_cast<std::string>(m_high->Eval()) :
+                            Description(m_high);
+    std::string description_str = "DESC_DESIGN_HAS_PART";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % low_str
+               % high_str
+               % m_name);
+}
+
+std::string Condition_2::DesignHasPart::Dump() const{
+    return DumpIndent() + "DesignHasPart low = " + Dump(m_low) + " high = " + Dump(m_high) + " name = " + m_name;
+}
+
+bool Condition_2::DesignHasPart::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "DesignHasPart::Match passed no candidate object";
+        return false;
+    }
+
+    int low =  std::max(0, m_low->Eval(local_context));
+    int high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+
+    return DesignHasPartSimpleMatch(candidate, low, high, m_name);
+}
+
+///////////////////////////////////////////////////////////
+// DesignHasPartClass                                    //
+///////////////////////////////////////////////////////////
+Condition_2::DesignHasPartClass::DesignHasPartClass(const ValueRef_2::Int& low,
+                                                  const ValueRef_2::Int& high,
+                                                  ShipPartClass part_class) :
+    m_low(low),
+    m_high(high),
+    m_class(part_class)
+{}
+
+namespace {
+    bool DesignHasPartClassSimpleMatch(const UniverseObject* candidate, int low, int high, ShipPartClass part_class)
+    {
+        if (!candidate)
+            return false;
+
+        // is it a ship?
+        const ::Ship* ship = universe_object_cast<const ::Ship*>(candidate);
+        if (!ship)
+            return false;
+        // with a valid design?
+        const ShipDesign* design = ship->Design();
+        if (!design)
+            return false;
+
+
+        const std::vector<std::string>& parts = design->Parts();
+        int count = 0;
+        for (std::vector<std::string>::const_iterator it = parts.begin(); it != parts.end(); ++it) {
+            if (const PartType* part_type = GetPartType(*it)) {
+                if (part_type->Class() == part_class)
+                    ++count;
+            }
+        }
+        return (low <= count && count < high);
+    }
+}
+
+void Condition_2::DesignHasPartClass::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = (LocalCandidateInvariant(m_low) && LocalCandidateInvariant(m_high) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate number limits once, use to match all candidates
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        int low =  std::max(0, m_low->Eval(local_context));
+        int high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = DesignHasPartClassSimpleMatch(*temp, low, high, m_class);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::DesignHasPartClass::RootCandidateInvariant() const
+{ return (RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high)); }
+
+bool Condition_2::DesignHasPartClass::TargetInvariant() const
+{ return (TargetInvariant(m_low) && TargetInvariant(m_high)); }
+
+std::string Condition_2::DesignHasPartClass::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                            boost::lexical_cast<std::string>(m_high->Eval()) :
+                            Description(m_high);
+    std::string description_str = "DESC_DESIGN_HAS_PART_CLASS";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % low_str
+               % high_str
+               % UserString(boost::lexical_cast<std::string>(m_class)));
+}
+
+std::string Condition_2::DesignHasPartClass::Dump() const{
+    return DumpIndent() + "DesignHasPartClass low = " + Dump(m_low) + " high = " + Dump(m_high) + " class = " + UserString(boost::lexical_cast<std::string>(m_class));
+}
+
+bool Condition_2::DesignHasPartClass::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "DesignHasPartClass::Match passed no candidate object";
+        return false;
+    }
+
+    int low =  std::max(0, m_low->Eval(local_context));
+    int high = std::min(m_high->Eval(local_context), IMPOSSIBLY_LARGE_TURN);
+
+    return DesignHasPartClassSimpleMatch(candidate, low, high, m_class);
+}
+
+///////////////////////////////////////////////////////////
+// PredefinedShipDesign                                         //
+///////////////////////////////////////////////////////////
+Condition_2::PredefinedShipDesign::PredefinedShipDesign(const std::string& name) :
+    m_name(name)
+{}
+
+std::string Condition_2::PredefinedShipDesign::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_PREDEFINED_SHIP_DESIGN";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % UserString(m_name));
+}
+
+std::string Condition_2::PredefinedShipDesign::Dump() const
+{
+    return DumpIndent() + "PredefinedShipDesign name = \"" + m_name + "\"\n";
+}
+
+bool Condition_2::PredefinedShipDesign::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "PredefinedShipDesign::Match passed no candidate object";
+        return false;
+    }
+
+    const Ship* ship = universe_object_cast<const Ship*>(candidate);
+    if (!ship)
+        return false;
+    const ShipDesign* candidate_design = ship->Design();
+    if (!candidate_design)
+        return false;
+
+    // ship has a valid design.  see if it is / could be a predefined ship design...
+
+    // all predefined named designs are hard-coded in parsing to have a designed on turn 0 (before first turn)
+    if (candidate_design->DesignedOnTurn() != 0)
+        return false;
+
+    // all predefined designs have a name, and that name should match the condition m_name
+    return (m_name == candidate_design->Name(false));   // don't look up in stringtable; predefined designs are stored by stringtable entry key
+}
+
+///////////////////////////////////////////////////////////
+// NumberedShipDesign                                      //
+///////////////////////////////////////////////////////////
+Condition_2::NumberedShipDesign::NumberedShipDesign(const ValueRef_2::Int& design_id) :
+    m_design_id(design_id)
+{}
+
+namespace {
+    bool NumberedShipDesignSimpleMatch(const UniverseObject* candidate, int design_id)
+    {
+        if (!candidate)
+            return false;
+        if (design_id == ShipDesign::INVALID_DESIGN_ID)
+            return false;
+        if (const Ship* ship = universe_object_cast<const Ship*>(candidate))
+            if (ship->DesignID() == design_id)
+                return true;
+        return false;
+    }
+}
+
+void Condition_2::NumberedShipDesign::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_design_id) ||
+                            (LocalCandidateInvariant(m_design_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int design_id = m_design_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = NumberedShipDesignSimpleMatch(*temp, design_id);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate design id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::NumberedShipDesign::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_design_id); }
+
+bool Condition_2::NumberedShipDesign::TargetInvariant() const
+{ return TargetInvariant(m_design_id); }
+
+std::string Condition_2::NumberedShipDesign::Description(bool negated/* = false*/) const
+{
+    std::string id_str = ValueRef_2::ConstantExpr(m_design_id) ?
+                            boost::lexical_cast<std::string>(m_design_id->Eval()) :
+                            Description(m_design_id);
+
+    std::string description_str = "DESC_NUMBERED_SHIP_DESIGN";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % id_str);
+}
+
+std::string Condition_2::NumberedShipDesign::Dump() const
+{
+    return DumpIndent() + "NumberedShipDesign design_id = " + Dump(m_design_id);
+}
+
+bool Condition_2::NumberedShipDesign::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "NumberedShipDesign::Match passed no candidate object";
+        return false;
+    }
+
+    return NumberedShipDesignSimpleMatch(candidate, m_design_id->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// ProducedByEmpire                                      //
+///////////////////////////////////////////////////////////
+Condition_2::ProducedByEmpire::ProducedByEmpire(const ValueRef_2::Int& empire_id) :
+    m_empire_id(empire_id)
+{}
+
+namespace {
+    bool ProducedByEmpireSimpleMatch(const UniverseObject* candidate, int empire_id)
+    {
+        if (!candidate)
+            return false;
+
+        if (const ::Ship* ship = universe_object_cast<const ::Ship*>(candidate))
+            return ship->ProducedByEmpireID() == empire_id;
+        else if (const ::Building* building = universe_object_cast<const ::Building*>(candidate))
+            return building->ProducedByEmpireID() == empire_id;
+        return false;
+    }
+}
+
+void Condition_2::ProducedByEmpire::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_empire_id) ||
+                            (LocalCandidateInvariant(m_empire_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int empire_id = m_empire_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = ProducedByEmpireSimpleMatch(*temp, empire_id);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::ProducedByEmpire::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_empire_id); }
+
+bool Condition_2::ProducedByEmpire::TargetInvariant() const
+{ return TargetInvariant(m_empire_id); }
+
+std::string Condition_2::ProducedByEmpire::Description(bool negated/* = false*/) const
+{
+    std::string empire_str;
+    if (m_empire_id) {
+        int empire_id = ALL_EMPIRES;
+        if (ValueRef_2::ConstantExpr(m_empire_id))
+            empire_id = m_empire_id->Eval();
+        if (const Empire* empire = Empires().Lookup(empire_id))
+            empire_str = empire->Name();
+        else
+            empire_str = Description(m_empire_id);
+    }
+
+    std::string description_str = "DESC_PRODUCED_BY_EMPIRE";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % empire_str);
+}
+
+std::string Condition_2::ProducedByEmpire::Dump() const
+{
+    return DumpIndent() + "ProducedByEmpire empire_id = " + Dump(m_empire_id);
+}
+
+bool Condition_2::ProducedByEmpire::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "ProducedByEmpire::Match passed no candidate object";
+        return false;
+    }
+
+    return ProducedByEmpireSimpleMatch(candidate, m_empire_id->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// Chance                                                //
+///////////////////////////////////////////////////////////
+Condition_2::Chance::Chance(const ValueRef_2::Double& chance) :
+    m_chance(chance)
+{}
+
+void Condition_2::Chance::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_chance) ||
+                            (LocalCandidateInvariant(m_chance) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        double chance = std::max(0.0, std::min(1.0, m_chance->Eval(ScriptingContext(parent_context, no_object))));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = RandZeroToOne() <= chance;
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::Chance::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_chance); }
+
+bool Condition_2::Chance::TargetInvariant() const
+{ return TargetInvariant(m_chance); }
+
+std::string Condition_2::Chance::Description(bool negated/* = false*/) const
+{
+    std::string value_str;
+    if (ValueRef_2::ConstantExpr(m_chance)) {
+        std::string description_str = "DESC_CHANCE_PERCENTAGE";
+        if (negated)
+            description_str += "_NOT";
+        return str(FlexibleFormat(UserString(description_str)) %
+                                  boost::lexical_cast<std::string>(std::max(0.0, std::min(m_chance->Eval(), 1.0)) * 100));
+    } else {
+        std::string description_str = "DESC_CHANCE";
+        if (negated)
+            description_str += "_NOT";
+        return str(FlexibleFormat(UserString(description_str)) % Description(m_chance));
+    }
+}
+
+std::string Condition_2::Chance::Dump() const
+{
+    return DumpIndent() + "Random probability = " + Dump(m_chance) + "\n";
+}
+
+bool Condition_2::Chance::Match(const ScriptingContext& local_context) const
+{
+    double chance = std::max(0.0, std::min(m_chance->Eval(local_context), 1.0));
+    return RandZeroToOne() <= chance;
+}
+
+///////////////////////////////////////////////////////////
+// MeterValue                                            //
+///////////////////////////////////////////////////////////
+Condition_2::MeterValue::MeterValue(MeterType meter, const ValueRef_2::Double& low, const ValueRef_2::Double& high) :
+    m_meter(meter),
+    m_low(low),
+    m_high(high)
+{}
+
+namespace {
+    bool MeterValueSimpleMatch(const UniverseObject* candidate, double low, double high, MeterType meter_type)
+    {
+        if (!candidate)
+            return false;
+
+        if (const Meter* meter = candidate->GetMeter(meter_type)) {
+            double value = meter->Initial();    // match Initial rather than Current to make results reproducible in a given turn, until back propegation happens
+            return low <= value && value < high;
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::MeterValue::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = (LocalCandidateInvariant(m_low) && LocalCandidateInvariant(m_high) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate number limits once, use to match all candidates
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        double low = m_low->Eval(local_context);
+        double high = m_high->Eval(local_context);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = MeterValueSimpleMatch(*temp, low, high, m_meter);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::MeterValue::RootCandidateInvariant() const
+{ return (RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high)); }
+
+bool Condition_2::MeterValue::TargetInvariant() const
+{ return (TargetInvariant(m_low) && TargetInvariant(m_high)); }
+
+std::string Condition_2::MeterValue::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                            boost::lexical_cast<std::string>(m_high->Eval()) :
+                            Description(m_high);
+    std::string description_str = "DESC_METER_VALUE_CURRENT";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % UserString(boost::lexical_cast<std::string>(m_meter))
+               % low_str
+               % high_str);
+}
+
+std::string Condition_2::MeterValue::Dump() const
+{
+    std::string retval = DumpIndent();
+    switch (m_meter) {
+    case INVALID_METER_TYPE:        retval += "INVALID_METER_TYPE"; break;
+    case METER_TARGET_POPULATION:   retval += "TargetPopulation";   break;
+    case METER_TARGET_HEALTH:       retval += "TargetHealth";       break;
+    case METER_TARGET_FARMING:      retval += "TargetFarming";      break;
+    case METER_TARGET_INDUSTRY:     retval += "TargetIndustry";     break;
+    case METER_TARGET_RESEARCH:     retval += "TargetResearch";     break;
+    case METER_TARGET_TRADE:        retval += "TargetTrade";        break;
+    case METER_TARGET_MINING:       retval += "TargetMining";       break;
+    case METER_TARGET_CONSTRUCTION: retval += "TargetConstruction"; break;
+    case METER_MAX_FUEL:            retval += "MaxFuel";            break;
+    case METER_MAX_SHIELD:          retval += "MaxShield";          break;
+    case METER_MAX_STRUCTURE:       retval += "MaxStructure";       break;
+    case METER_MAX_DEFENSE:         retval += "MaxDefense";         break;
+    case METER_POPULATION:          retval += "Population";         break;
+    case METER_HEALTH:              retval += "Health";             break;
+    case METER_FARMING:             retval += "Farming";            break;
+    case METER_INDUSTRY:            retval += "Industry";           break;
+    case METER_RESEARCH:            retval += "Research";           break;
+    case METER_TRADE:               retval += "Trade";              break;
+    case METER_MINING:              retval += "Mining";             break;
+    case METER_CONSTRUCTION:        retval += "Construction";       break;
+    case METER_FUEL:                retval += "Fuel";               break;
+    case METER_SHIELD:              retval += "Shield";             break;
+    case METER_STRUCTURE:           retval += "Structure";          break;
+    case METER_DEFENSE:             retval += "Defense";            break;
+    case METER_FOOD_CONSUMPTION:    retval += "FoodConsumption";    break;
+    case METER_SUPPLY:              retval += "Supply";             break;
+    case METER_STEALTH:             retval += "Stealth";            break;
+    case METER_DETECTION:           retval += "Detection";          break;
+    case METER_BATTLE_SPEED:        retval += "BattleSpeed";        break;
+    case METER_STARLANE_SPEED:      retval += "StarlaneSpeed";      break;
+    case METER_DAMAGE:              retval += "Damage";             break;
+    case METER_ROF:                 retval += "ROF";                break;
+    case METER_RANGE:               retval += "Range";              break;
+    case METER_SPEED:               retval += "Speed";              break;
+    case METER_CAPACITY:            retval += "Capacity";           break;
+    case METER_ANTI_SHIP_DAMAGE:    retval += "AntiShipDamage";     break;
+    case METER_ANTI_FIGHTER_DAMAGE: retval += "AntiFighterDamage";  break;
+    case METER_LAUNCH_RATE:         retval += "LaunchRate";         break;
+    case METER_FIGHTER_WEAPON_RANGE:retval += "FighterWeaponRange"; break;
+    default: retval += "?Meter?"; break;
+    }
+    retval += " low = " + Dump(m_low) + " high = " + Dump(m_high) + "\n";
+    return retval;
+}
+
+bool Condition_2::MeterValue::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "MeterValue::Match passed no candidate object";
+        return false;
+    }
+
+    double low = m_low->Eval(local_context);
+    double high = m_high->Eval(local_context);
+    return MeterValueSimpleMatch(candidate, low, high, m_meter);
+}
+
+///////////////////////////////////////////////////////////
+// EmpireStockpileValue                                  //
+///////////////////////////////////////////////////////////
+Condition_2::EmpireStockpileValue::EmpireStockpileValue(ResourceType stockpile, const ValueRef_2::Double& low, const ValueRef_2::Double& high) :
+    m_stockpile(stockpile),
+    m_low(low),
+    m_high(high)
+{}
+
+namespace {
+    bool EmpireStockpileValueSimpleMatch(const UniverseObject* candidate, double low, double high, ResourceType stockpile)
+    {
+        if (!candidate)
+            return false;
+
+        if (candidate->Unowned())
+            return false;
+
+        const Empire* empire = Empires().Lookup(candidate->Owner());
+        if (!empire)
+            return false;
+
+        if (stockpile == RE_FOOD || stockpile == RE_MINERALS || stockpile == RE_TRADE) {
+            double amount = empire->ResourceStockpile(stockpile);
+            return (low <= amount && amount <= high);
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::EmpireStockpileValue::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = (LocalCandidateInvariant(m_low) && LocalCandidateInvariant(m_high) &&
+                             (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate number limits once, use to match all candidates
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+        double low = m_low->Eval(local_context);
+        double high = m_high->Eval(local_context);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = EmpireStockpileValueSimpleMatch(*temp, low, high, m_stockpile);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate allowed turn range for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::EmpireStockpileValue::RootCandidateInvariant() const
+{ return (RootCandidateInvariant(m_low) && RootCandidateInvariant(m_high)); }
+
+bool Condition_2::EmpireStockpileValue::TargetInvariant() const
+{ return (TargetInvariant(m_low) && TargetInvariant(m_high)); }
+
+std::string Condition_2::EmpireStockpileValue::Description(bool negated/* = false*/) const
+{
+    std::string low_str = ValueRef_2::ConstantExpr(m_low) ?
+                            boost::lexical_cast<std::string>(m_low->Eval()) :
+                            Description(m_low);
+    std::string high_str = ValueRef_2::ConstantExpr(m_high) ?
+                            boost::lexical_cast<std::string>(m_high->Eval()) :
+                            Description(m_high);
+    std::string description_str = "DESC_EMPIRE_STOCKPILE_VALUE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % UserString(boost::lexical_cast<std::string>(m_stockpile))
+               % low_str
+               % high_str);
+}
+
+std::string Condition_2::EmpireStockpileValue::Dump() const
+{
+    std::string retval = DumpIndent();
+    switch (m_stockpile) {
+    case RE_FOOD:       retval += "OwnerFoodStockpile";     break;
+    case RE_MINERALS:   retval += "OwnerMineralStockpile";  break;
+    case RE_TRADE:      retval += "OwnerTradeStockpile";    break;
+    case RE_RESEARCH:   retval += "OwnerResearchStockpile"; break;
+    case RE_INDUSTRY:   retval += "OwnerIndustryStockpile"; break;
+    default: retval += "?"; break;
+    }
+    retval += " low = " + Dump(m_low) + " high = " + Dump(m_high) + "\n";
+    return retval;
+}
+
+bool Condition_2::EmpireStockpileValue::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "MeterValue::Match passed no candidate object";
+        return false;
+    }
+
+    double low = m_low->Eval(local_context);
+    double high = m_high->Eval(local_context);
+    return EmpireStockpileValueSimpleMatch(candidate, low, high, m_stockpile);
+}
+
+///////////////////////////////////////////////////////////
+// OwnerHasTech                                          //
+///////////////////////////////////////////////////////////
+Condition_2::OwnerHasTech::OwnerHasTech(const std::string& name) :
+    m_name(name)
+{}
+
+std::string Condition_2::OwnerHasTech::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_OWNER_HAS_TECH";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % UserString(m_name));
+}
+
+std::string Condition_2::OwnerHasTech::Dump() const
+{
+    return DumpIndent() + "OwnerHasTech name = \"" + m_name + "\"\n";
+}
+
+bool Condition_2::OwnerHasTech::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "OwnerHasTech::Match passed no candidate object";
+        return false;
+    }
+
+    if (candidate->Unowned())
+        return false;
+
+    if (const Empire* empire = Empires().Lookup(candidate->Owner()))
+        return empire->TechResearched(m_name);
+    else
+        return false;
+}
+
+///////////////////////////////////////////////////////////
+// VisibleToEmpire                                       //
+///////////////////////////////////////////////////////////
+Condition_2::VisibleToEmpire::VisibleToEmpire(const ValueRef_2::Int& empire_id) :
+    m_empire_id(empire_id)
+{}
+
+void Condition_2::VisibleToEmpire::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_empire_id) ||
+                            (LocalCandidateInvariant(m_empire_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int empire_id = m_empire_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = (*temp)->GetVisibility(empire_id) != VIS_NO_VISIBILITY;
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::VisibleToEmpire::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_empire_id); }
+
+bool Condition_2::VisibleToEmpire::TargetInvariant() const
+{ return TargetInvariant(m_empire_id); }
+
+std::string Condition_2::VisibleToEmpire::Description(bool negated/* = false*/) const
+{
+    std::string empire_str;
+    if (m_empire_id) {
+        int empire_id = ALL_EMPIRES;
+        if (ValueRef_2::ConstantExpr(m_empire_id))
+            empire_id = m_empire_id->Eval();
+        if (const Empire* empire = Empires().Lookup(empire_id))
+            empire_str = empire->Name();
+        else
+            empire_str = Description(m_empire_id);
+    }
+
+    std::string description_str = "DESC_VISIBLE_TO_EMPIRE";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % empire_str);
+}
+
+std::string Condition_2::VisibleToEmpire::Dump() const
+{
+    return DumpIndent() + "VisibleToEmpire empire_id = " + Dump(m_empire_id);
+}
+
+bool Condition_2::VisibleToEmpire::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "VisibleToEmpire::Match passed no candidate object";
+        return false;
+    }
+
+    return candidate->GetVisibility(m_empire_id->Eval(local_context)) != VIS_NO_VISIBILITY;
+}
+
+///////////////////////////////////////////////////////////
+// WithinDistance                                        //
+///////////////////////////////////////////////////////////
+Condition_2::WithinDistance::WithinDistance(const ValueRef_2::Double& distance, const ConditionBase* condition) :
+    m_distance(distance),
+    m_condition(condition)
+{}
+
+Condition_2::WithinDistance::~WithinDistance()
+{ delete m_condition; }
+
+namespace {
+    bool WithinDistanceSimpleMatch(const UniverseObject* candidate, const Condition_2::ObjectSet& from_objects, double distance)
+    {
+        if (!candidate)
+            return false;
+
+        double distance2 = distance*distance;
+
+        // is candidate object close enough to any of the passed-in objects?
+        for (Condition_2::ObjectSet::const_iterator it = from_objects.begin(); it != from_objects.end(); ++it) {
+            double delta_x = candidate->X() - (*it)->X();
+            double delta_y = candidate->Y() - (*it)->Y();
+            if (delta_x*delta_x + delta_y*delta_y < distance2)
+                return true;
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::WithinDistance::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = LocalCandidateInvariant(m_distance) &&
+                            parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // evaluate contained objects once and check for all candidates
+        ObjectMap& objects = GetUniverse().Objects();
+
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+
+        // get objects to be considering for matching against subcondition
+        ObjectSet subcondition_non_matches;
+        for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+            subcondition_non_matches.insert(it->second);
+        ObjectSet subcondition_matches;
+
+        m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+        double distance = m_distance->Eval(local_context);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            // does candidate object contain any subcondition matches?
+            bool match = WithinDistanceSimpleMatch(*temp, subcondition_matches, distance);
+            // transfer
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::WithinDistance::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_distance) && m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::WithinDistance::TargetInvariant() const
+{ return TargetInvariant(m_distance) && m_condition->TargetInvariant(); }
+
+std::string Condition_2::WithinDistance::Description(bool negated/* = false*/) const
+{
+    std::string value_str = ValueRef_2::ConstantExpr(m_distance) ?
+                                boost::lexical_cast<std::string>(m_distance->Eval()) :
+                                Description(m_distance);
+    std::string description_str = "DESC_WITHIN_DISTANCE";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % value_str
+               % m_condition->Description());
+}
+
+std::string Condition_2::WithinDistance::Dump() const
+{
+    std::string retval = DumpIndent() + "WithinDistance distance = " + Dump(m_distance) + " condition =\n";
+    ++g_indent;
+    retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+bool Condition_2::WithinDistance::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "WithinDistance::Match passed no candidate object";
+        return false;
+    }
+
+    ObjectMap& objects = GetUniverse().Objects();
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+    if (subcondition_matches.empty())
+        return false;
+
+    return WithinDistanceSimpleMatch(candidate, subcondition_matches, m_distance->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// WithinStarlaneJumps                                   //
+///////////////////////////////////////////////////////////
+Condition_2::WithinStarlaneJumps::WithinStarlaneJumps(const ValueRef_2::Int& jumps, const ConditionBase* condition) :
+    m_jumps(jumps),
+    m_condition(condition)
+{}
+
+Condition_2::WithinStarlaneJumps::~WithinStarlaneJumps()
+{ delete m_condition; }
+
+namespace {
+    int MANY_JUMPS(999999);
+
+    int JumpsBetweenObjects(const UniverseObject* one, const UniverseObject* two) {
+        ObjectMap& objects = GetUniverse().Objects();
+
+        if (!one || !two)
+            return MANY_JUMPS;
+
+        // determine if objects are systems
+        const System* system_one = objects.Object<System>(one->SystemID());
+        const System* system_two = objects.Object<System>(two->SystemID());
+
+        // need various special cases for whether the condition-matching object
+        // and candidate objects are or are in systems.
+        if (system_one && system_two) {
+            // both condition-matching object and candidate are / in systems.
+            // can just find the shortest path between the two systems
+            std::pair<std::list<int>, double> path = GetUniverse().LeastJumpsPath(system_one->ID(), system_two->ID());
+            if (!path.first.empty())    // if path.first is empty, no path exists between the systems
+                return static_cast<int>(path.first.size() - 1);
+
+        } else if (system_one) {
+            // just object one is / in a system.
+            if (const Fleet* fleet = FleetFromObject(two)) {
+                // other object is a fleet that is between systems
+                // need to check shortest path from systems on either side of starlane fleet is on
+                std::pair<std::list<int>, double> path1 = GetUniverse().LeastJumpsPath(system_one->ID(), fleet->PreviousSystemID());
+                std::pair<std::list<int>, double> path2 = GetUniverse().LeastJumpsPath(system_one->ID(), fleet->NextSystemID());
+                if (int jumps = static_cast<int>(std::max(path1.first.size(), path2.first.size())))
+                    return jumps - 1;
+            }
+
+        } else if (system_two) {
+            // just object two is a system.
+            if (const Fleet* fleet = FleetFromObject(two)) {
+                // other object is a fleet that is between systems
+                // need to check shortest path from systems on either side of starlane fleet is on
+                std::pair<std::list<int>, double> path1 = GetUniverse().LeastJumpsPath(system_two->ID(), fleet->PreviousSystemID());
+                std::pair<std::list<int>, double> path2 = GetUniverse().LeastJumpsPath(system_two->ID(), fleet->NextSystemID());
+                if (int jumps = static_cast<int>(std::max(path1.first.size(), path2.first.size())))
+                    return jumps - 1;
+            }
+
+        } else {
+            // neither object is / in a system
+
+            const Fleet* fleet_one = FleetFromObject(one);
+            const Fleet* fleet_two = FleetFromObject(two);
+
+            if (fleet_one && fleet_two) {
+                // both objects are / in a fleet.
+                // need to check all combinations of systems on either sides of
+                // starlanes condition-matching object and candidate are on
+
+                int fleet_one_prev_system_id = fleet_one->PreviousSystemID();
+                int fleet_one_next_system_id = fleet_one->NextSystemID();
+                int fleet_two_prev_system_id = fleet_two->PreviousSystemID();
+                int fleet_two_next_system_id = fleet_two->NextSystemID();
+
+                std::pair<std::list<int>, int> path1 = GetUniverse().LeastJumpsPath(fleet_one_prev_system_id, fleet_two_prev_system_id);
+                std::pair<std::list<int>, int> path2 = GetUniverse().LeastJumpsPath(fleet_one_prev_system_id, fleet_two_next_system_id);
+                std::pair<std::list<int>, int> path3 = GetUniverse().LeastJumpsPath(fleet_one_next_system_id, fleet_two_prev_system_id);
+                std::pair<std::list<int>, int> path4 = GetUniverse().LeastJumpsPath(fleet_one_next_system_id, fleet_two_next_system_id);
+                if (int jumps = static_cast<int>(std::max(std::max(path1.second, path2.second),
+                                                          std::max(path3.second, path4.second))))
+                    return jumps - 1;
+            }
+
+        }
+        return MANY_JUMPS;
+    }
+
+    bool WithinStarlaneJumpsSimpleMatch(const UniverseObject* candidate, const Condition_2::ObjectSet& from_objects, int jump_limit)
+    {
+        if (!candidate)
+            return false;
+        if (from_objects.empty())
+            return false;
+        if (jump_limit < 0)
+            return false;
+
+        // is candidate object close enough to any subcondition matches?
+        for (Condition_2::ObjectSet::const_iterator it = from_objects.begin(); it != from_objects.end(); ++it) {
+            if (jump_limit == 0) {
+                // special case, since LeastJumpsPath() doesn't expect the start point to be the end point
+                double delta_x = (*it)->X() - candidate->X();
+                double delta_y = (*it)->Y() - candidate->Y();
+                if (delta_x*delta_x + delta_y*delta_y == 0)
+                    return true;
+            } else {
+                int jumps = JumpsBetweenObjects(*it, candidate);
+                if (jumps <= jump_limit)
+                    return true;
+            }
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::WithinStarlaneJumps::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = LocalCandidateInvariant(m_jumps) &&
+                            parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // evaluate contained objects once and check for all candidates
+        ObjectMap& objects = GetUniverse().Objects();
+
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+
+        // get objects to be considering for matching against subcondition
+        ObjectSet subcondition_non_matches;
+        for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+            subcondition_non_matches.insert(it->second);
+        ObjectSet subcondition_matches;
+
+        m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+        int jump_limit = m_jumps->Eval(local_context);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            // does candidate object contain any subcondition matches?
+            bool match = WithinStarlaneJumpsSimpleMatch(*temp, subcondition_matches, jump_limit);
+            // transfer
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::WithinStarlaneJumps::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_jumps) && m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::WithinStarlaneJumps::TargetInvariant() const
+{ return TargetInvariant(m_jumps) && m_condition->TargetInvariant(); }
+
+std::string Condition_2::WithinStarlaneJumps::Description(bool negated/* = false*/) const
+{
+    std::string value_str = ValueRef_2::ConstantExpr(m_jumps) ? boost::lexical_cast<std::string>(m_jumps->Eval()) : Description(m_jumps);
+    std::string description_str = "DESC_WITHIN_STARLANE_JUMPS";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str))
+               % value_str
+               % m_condition->Description());
+}
+
+std::string Condition_2::WithinStarlaneJumps::Dump() const
+{
+    std::string retval = DumpIndent() + "WithinStarlaneJumps jumps = " + Dump(m_jumps) + " condition =\n";
+    ++g_indent;
+    retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+bool Condition_2::WithinStarlaneJumps::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "WithinStarlaneJumps::Match passed no candidate object";
+        return false;
+    }
+
+    ObjectMap& objects = GetUniverse().Objects();
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+    int jump_limit = m_jumps->Eval(local_context);
+
+    return WithinStarlaneJumpsSimpleMatch(candidate, subcondition_matches, jump_limit);
+}
+
+///////////////////////////////////////////////////////////
+// CanAddStarlaneConnection                              //
+///////////////////////////////////////////////////////////
+Condition_2::CanAddStarlaneConnection::CanAddStarlaneConnection(const ConditionBase* condition) :
+    m_condition(condition)
+{}
+
+Condition_2::CanAddStarlaneConnection::~CanAddStarlaneConnection()
+{ delete m_condition; }
+
+namespace {
+    bool CanAddStarlaneConnectionSimpleMatch(const UniverseObject* candidate, const Condition_2::ObjectSet& destination_objects)
+    {
+        if (!candidate)
+            return false;
+
+        ObjectMap& objects = GetUniverse().Objects();
+
+        // assemble all systems that are or that contain subcondition matches
+        Condition_2::ObjectSet destination_systems;
+        for (Condition_2::ObjectSet::const_iterator it = destination_objects.begin(); it != destination_objects.end(); ++it)
+            if (const System* system = objects.Object< ::System>((*it)->SystemID()))
+                destination_systems.insert(system);
+
+        if (destination_systems.empty())
+            return false;
+
+        // TODO: implement this test
+
+        // can the candidate object have starlanes added to all destination systems?
+        for (Condition_2::ObjectSet::const_iterator it = destination_systems.begin(); it != destination_systems.end(); ++it) {
+            return false;
+        }
+
+        return true;
+    }
+}
+
+void Condition_2::CanAddStarlaneConnection::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = parent_context.condition_root_candidate || RootCandidateInvariant();
+    if (simple_eval_safe) {
+        // evaluate contained objects once and check for all candidates
+        ObjectMap& objects = GetUniverse().Objects();
+
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+
+        // get objects to be considering for matching against subcondition
+        ObjectSet subcondition_non_matches;
+        for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+            subcondition_non_matches.insert(it->second);
+        ObjectSet subcondition_matches;
+
+        m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            // can starlanes be added between candidate and all subcondition matches?
+            bool match = CanAddStarlaneConnectionSimpleMatch(*temp, subcondition_matches);
+            // transfer
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+    } else {
+        // re-evaluate contained objects for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::CanAddStarlaneConnection::RootCandidateInvariant() const
+{ return m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::CanAddStarlaneConnection::TargetInvariant() const
+{ return m_condition->TargetInvariant(); }
+
+std::string Condition_2::CanAddStarlaneConnection::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_CAN_ADD_STARLANE_CONNECTION";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % m_condition->Description());
+}
+
+std::string Condition_2::CanAddStarlaneConnection::Dump() const
+{
+    std::string retval = DumpIndent() + "CanAddStarlaneConnection condition =\n";
+    ++g_indent;
+        retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+bool Condition_2::CanAddStarlaneConnection::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "CanAddStarlaneConnection::Match passed no candidate object";
+        return false;
+    }
+
+    ObjectMap& objects = GetUniverse().Objects();
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+    return CanAddStarlaneConnectionSimpleMatch(candidate, subcondition_matches);
+}
+
+///////////////////////////////////////////////////////////
+// CanRemoveStarlaneConnection                           //
+///////////////////////////////////////////////////////////
+namespace {
+    struct vertex_system_id_t {typedef boost::vertex_property_tag kind;}; ///< a system graph property map type
+
+    struct GraphImpl {
+        typedef boost::property<vertex_system_id_t, int,
+                                boost::property<boost::vertex_index_t, int> >   vertex_property_t;  ///< a system graph property map type
+
+        // declare main graph types, including properties declared above
+        typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS,
+                                      vertex_property_t> SystemGraph;
+
+        // declare property map types for properties declared above
+        typedef boost::property_map<SystemGraph, vertex_system_id_t>::const_type        ConstSystemIDPropertyMap;
+        typedef boost::property_map<SystemGraph, vertex_system_id_t>::type              SystemIDPropertyMap;
+
+        SystemGraph system_graph;   ///< a graph in which the systems are vertices and the starlanes are edges
+    };
+
+    // returns the \a graph index for system with id \a system_id
+    template <class Graph>
+    int SystemGraphIndex(const Graph& graph, int system_id)
+    {
+        typedef typename boost::property_map<Graph, vertex_system_id_t>::const_type ConstSystemIDPropertyMap;
+        ConstSystemIDPropertyMap sys_id_property_map = boost::get(vertex_system_id_t(), graph);
+
+        for (unsigned int i = 0; i < boost::num_vertices(graph); ++i) {
+            const int loop_sys_id = sys_id_property_map[i];    // get system ID of this vertex
+            if (loop_sys_id == system_id)
+                return i;
+        }
+
+        Logger().errorStream() << "SystemGraphIndex cannot be found due to invalid system ID: " << system_id;
+        return -1;
+    }
+
+    void InitializeStarlaneGraph(GraphImpl& starlane_graph_impl,
+                                 const std::map<int, std::set<int> >& system_starlanes_map)
+    {
+        // clean up old contents of input graph
+        for (int i = static_cast<int>(boost::num_vertices(starlane_graph_impl.system_graph)) - 1; i >= 0; --i) {
+            boost::clear_vertex(i, starlane_graph_impl.system_graph);
+            boost::remove_vertex(i, starlane_graph_impl.system_graph);
+        }
+
+        GraphImpl::SystemIDPropertyMap sys_id_property_map =
+            boost::get(vertex_system_id_t(), starlane_graph_impl.system_graph);
+
+        std::map<int, int> system_id_graph_index_reverse_lookup_map;    // key is system ID, value is index in starlane_graph_impl.system_graph of system's vertex
+
+        // add vertices
+        unsigned int i = 0;
+        for (std::map<int, std::set<int> >::const_iterator map_it = system_starlanes_map.begin();
+             map_it != system_starlanes_map.end(); ++map_it, ++i)
+        {
+            int system_id = map_it->first;
+
+            // add a vertex to the graph for this system, and assign it the system's universe ID as a property
+            boost::add_vertex(starlane_graph_impl.system_graph);
+            sys_id_property_map[i] = system_id;
+            // add record of index in starlane_graph_impl.system_graph of this system
+            system_id_graph_index_reverse_lookup_map[system_id] = i;
+        }
+
+        // add edges
+        for (std::map<int, std::set<int> >::const_iterator map_it = system_starlanes_map.begin();
+             map_it != system_starlanes_map.end(); ++map_it)
+        {
+            int system1_id = map_it->first;
+            // find lane start graph index
+            std::map<int, int>::const_iterator lookup1_it = system_id_graph_index_reverse_lookup_map.find(system1_id);
+            if (lookup1_it == system_id_graph_index_reverse_lookup_map.end())
+                continue;
+            int system1_index = lookup1_it->second;
+            // add edge for each valid starlane
+            const std::set<int>& system_starlanes = map_it->second;
+            for (std::set<int>::const_iterator lane_it = system_starlanes.begin();
+                 lane_it != system_starlanes.end(); ++lane_it)
+            {
+                int system2_id = *lane_it;
+                // skip null lanes
+                if (system2_id == system1_id)
+                    continue;
+                // find lane end graph index
+                std::map<int, int>::const_iterator lookup2_it = system_id_graph_index_reverse_lookup_map.find(system2_id);
+                if (lookup2_it == system_id_graph_index_reverse_lookup_map.end())
+                    continue;
+                int system2_index = lookup2_it->second;
+                // add edge between vertices
+                boost::add_edge(system1_index, system2_index, starlane_graph_impl.system_graph);
+            }
+        }
+    }
+
+    /** Returns true or false to indicate whether the systems with ids
+      * \a system1_id and system2_id are connected by a series of starlanes. */
+    template <class Graph>
+    bool SystemsConnected(const Graph& graph, int system1_id, int system2_id)
+    {
+        if (system1_id == system2_id)
+            return true;    // early exit if systems are the same
+
+        int system1_index = SystemGraphIndex(graph, system1_id);
+        int system2_index = SystemGraphIndex(graph, system2_id);
+        if (system1_index == -1 || system2_index == -1) {
+            Logger().errorStream() << "Couldn't find valid graph index for systems " << system1_id << " or " << system2_id;
+            return false;
+        }
+
+        try {
+            return boost::graph::st_connected(graph, system1_index, system2_index);
+        } catch(...) {
+            Logger().errorStream() << "Error checking graph connectivity in Condition";
+        }
+        return false;
+    }
+}
+
+Condition_2::CanRemoveStarlaneConnection::CanRemoveStarlaneConnection(const ConditionBase* condition) :
+    m_condition(condition)
+{}
+
+Condition_2::CanRemoveStarlaneConnection::~CanRemoveStarlaneConnection()
+{ delete m_condition; }
+
+bool Condition_2::CanRemoveStarlaneConnection::RootCandidateInvariant() const
+{ return m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::CanRemoveStarlaneConnection::TargetInvariant() const
+{ return m_condition->TargetInvariant(); }
+
+std::string Condition_2::CanRemoveStarlaneConnection::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_CAN_REMOVE_STARLANE_CONNECTION";
+    if (negated)
+        description_str += "_NOT";
+    return str(FlexibleFormat(UserString(description_str)) % m_condition->Description());
+}
+
+std::string Condition_2::CanRemoveStarlaneConnection::Dump() const
+{
+    std::string retval = DumpIndent() + "CanRemoveStarlaneConnection condition =\n";
+    ++g_indent;
+        retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+bool Condition_2::CanRemoveStarlaneConnection::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "CanRemoveStarlaneConnection::Match passed no candidate object";
+        return false;
+    }
+
+    const ObjectMap& objects = GetMainObjectMap();
+
+    // get system for candidate object
+    int candidate_system_id = candidate->SystemID();
+    const System* candidate_system = objects.Object<System>(candidate_system_id);
+    if (!candidate_system)
+        return false;
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::const_iterator it = objects.const_begin(); it != objects.const_end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+    if (subcondition_matches.empty())
+        return false;
+
+    // assemble all systems in or containing objects in subcondition matches
+    std::set<const System*> destination_systems;
+    for (ObjectSet::const_iterator it = subcondition_matches.begin(); it != subcondition_matches.end(); ++it)
+        if (const System* system = objects.Object<System>((*it)->SystemID()))
+            destination_systems.insert(system);
+
+    if (destination_systems.empty())
+        return false;
+
+    // does the candidate object have starlanes to all systems containing subcondition matches?
+    for (std::set<const System*>::const_iterator it = destination_systems.begin(); it != destination_systems.end(); ++it) {
+        if (!candidate_system->HasStarlaneTo((*it)->ID()) || !(*it)->HasStarlaneTo(candidate_system->ID()))
+            return false;
+    }
+
+    // create starlane graph, fill with system info, exclusing lanes to
+    // subcondition-matches from candidate
+    std::map<int, std::set<int> > system_lanes;
+    std::vector<const System*> systems = objects.FindObjects<System>();
+
+    //for (std::vector<const System*>::const_iterator system_it = systems.begin(); system_it != systems.end(); ++system_it) {
+    //    const System* loop_system = *system_it;
+    //    int loop_system_id = loop_system->ID();
+    //    system_lanes[loop_system_id];   // ensure there's at least an empty lane set for this system
+
+    //    // Add all lanes for each system to system_lanes map, except for lanes
+    //    // connecting between the candidate and any subcondition matcing system
+    //    // (and also lanes from subcondition matches to the candidate system)
+    //    for (System::const_lane_iterator lane_it = loop_system->begin_lanes(); lane_it != loop_system->end_lanes(); ++lane_it) {
+    //        if (loop_system_id != candidate_system_id ||
+    //            destination_systems.find(*lane_it) == destination_systems.end() ||
+    //            false)
+    //        {
+    //            system_lanes[loop_system_id].insert(*lane_it);
+    //        }
+    //    }
+    //}
+
+    GraphImpl graph_impl;
+    InitializeStarlaneGraph(graph_impl, system_lanes);
+
+    // In the starlanes graph that excludes the starlanes being tested, is
+    // connectivity still preserved between systems connected by those starlanes?
+    // To test, check if any of those pairs of systems are disconnected in the
+    // test graph.
+    for (std::set<const System*>::const_iterator it = destination_systems.begin(); it != destination_systems.end(); ++it) {}
+
+    //SystemsConnected(graph_impl
+    return true;
+}
+
+///////////////////////////////////////////////////////////
+// ExploredByEmpire                                      //
+///////////////////////////////////////////////////////////
+Condition_2::ExploredByEmpire::ExploredByEmpire(const ValueRef_2::Int& empire_id) :
+    m_empire_id(empire_id)
+{}
+
+namespace {
+    bool ExploredByEmpireSimpleMatch(const UniverseObject* candidate, int empire_id)
+    {
+        if (!candidate)
+            return false;
+
+        const Empire* empire = Empires().Lookup(empire_id);
+        if (!empire)
+            return false;
+        return empire->HasExploredSystem(candidate->ID());
+    }
+}
+
+void Condition_2::ExploredByEmpire::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_empire_id) ||
+                            (LocalCandidateInvariant(m_empire_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int empire_id = m_empire_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = ExploredByEmpireSimpleMatch(*temp, empire_id);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::ExploredByEmpire::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_empire_id); }
+
+bool Condition_2::ExploredByEmpire::TargetInvariant() const
+{ return TargetInvariant(m_empire_id); }
+
+std::string Condition_2::ExploredByEmpire::Description(bool negated/* = false*/) const
+{
+    std::string empire_str;
+    if (m_empire_id) {
+        int empire_id = ALL_EMPIRES;
+        if (ValueRef_2::ConstantExpr(m_empire_id))
+            empire_id = m_empire_id->Eval();
+        if (const Empire* empire = Empires().Lookup(empire_id))
+            empire_str = empire->Name();
+        else
+            empire_str = Description(m_empire_id);
+    }
+
+    std::string description_str = "DESC_EXPLORED_BY_EMPIRE";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % empire_str);
+}
+
+std::string Condition_2::ExploredByEmpire::Dump() const
+{
+    return DumpIndent() + "ExploredByEmpire empire_id = " + Dump(m_empire_id);
+}
+
+bool Condition_2::ExploredByEmpire::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "ExploredByEmpire::Match passed no candidate object";
+        return false;
+    }
+
+    return ExploredByEmpireSimpleMatch(candidate, m_empire_id->Eval(local_context));
+}
+
+///////////////////////////////////////////////////////////
+// Stationary                                      //
+///////////////////////////////////////////////////////////
+Condition_2::Stationary::Stationary()
+{}
+
+std::string Condition_2::Stationary::Description(bool negated/* = false*/) const
+{
+    std::string description_str = "DESC_STATIONARY";
+    if (negated)
+        description_str += "_NOT";
+    return UserString(description_str);
+}
+
+std::string Condition_2::Stationary::Dump() const
+{
+    return DumpIndent() + "Stationary\n";
+}
+
+bool Condition_2::Stationary::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "Stationary::Match passed no candidate object";
+        return false;
+    }
+
+    const ObjectMap& objects = GetMainObjectMap();
+    // the only objects that can move are fleets and the ships in them.  so,
+    // attempt to cast the candidate object to a fleet or ship, and if it's a ship
+    // get the fleet of that ship
+    const Fleet* fleet = universe_object_cast<const Fleet*>(candidate);
+    if (!fleet)
+        if (const Ship* ship = universe_object_cast<const Ship*>(candidate))
+            fleet = objects.Object<Fleet>(ship->FleetID());
+
+    if (fleet) {
+        // if a fleet is available, it is "moving", or not stationary, if it's
+        // next system is a system and isn't the current system.  This will
+        // mean fleets that have arrived at a system on the current turn will
+        // be stationary, but fleets departing won't be stationary.
+        int next_id = fleet->NextSystemID();
+        int cur_id = fleet->SystemID();
+        if (next_id != UniverseObject::INVALID_OBJECT_ID && next_id != cur_id)
+            return false;
+    }
+
+    return true;
+}
+
+///////////////////////////////////////////////////////////
+// FleetSupplyableByEmpire                               //
+///////////////////////////////////////////////////////////
+Condition_2::FleetSupplyableByEmpire::FleetSupplyableByEmpire(const ValueRef_2::Int& empire_id) :
+    m_empire_id(empire_id)
+{}
+
+namespace {
+    bool FleetSupplyableSimpleMatch(const UniverseObject* candidate, int empire_id) {
+        if (!candidate)
+            return false;
+
+        const EmpireManager& empires = Empires();
+        const Empire* empire = empires.Lookup(empire_id);
+        if (!empire)
+            return false;
+
+        const std::set<int>& supplyable_systems = empire->FleetSupplyableSystemIDs();
+        return supplyable_systems.find(candidate->SystemID()) != supplyable_systems.end();
+    }
+}
+
+void Condition_2::FleetSupplyableByEmpire::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_empire_id) ||
+                            (LocalCandidateInvariant(m_empire_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate empire id once, and use to check all candidate objects
+        const UniverseObject* no_object(0);
+        int empire_id = m_empire_id->Eval(ScriptingContext(parent_context, no_object));
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = FleetSupplyableSimpleMatch(*temp, empire_id);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::FleetSupplyableByEmpire::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_empire_id); }
+
+bool Condition_2::FleetSupplyableByEmpire::TargetInvariant() const
+{ return TargetInvariant(m_empire_id); }
+
+std::string Condition_2::FleetSupplyableByEmpire::Description(bool negated/* = false*/) const
+{
+    std::string empire_str;
+    if (m_empire_id) {
+        int empire_id = ALL_EMPIRES;
+        if (ValueRef_2::ConstantExpr(m_empire_id))
+            empire_id = m_empire_id->Eval();
+        if (const Empire* empire = Empires().Lookup(empire_id))
+            empire_str = empire->Name();
+        else
+            empire_str = Description(m_empire_id);
+    }
+
+    std::string description_str = "DESC_SUPPLY_CONNECTED_FLEET";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % empire_str);
+}
+
+std::string Condition_2::FleetSupplyableByEmpire::Dump() const
+{
+    return DumpIndent() + "FleetSupplyableByEmpire empire_id = " + Dump(m_empire_id);
+}
+
+bool Condition_2::FleetSupplyableByEmpire::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "FleetSupplyableByEmpire::Match passed no candidate object";
+        return false;
+    }
+
+    int empire_id = m_empire_id->Eval(local_context);
+
+    return FleetSupplyableSimpleMatch(candidate, empire_id);
+}
+
+///////////////////////////////////////////////////////////
+// ResourceSupplyConnectedByEmpire                       //
+///////////////////////////////////////////////////////////
+Condition_2::ResourceSupplyConnectedByEmpire::ResourceSupplyConnectedByEmpire(const ValueRef_2::Int& empire_id,
+                                                                            const ConditionBase* condition) :
+    m_empire_id(empire_id),
+    m_condition(condition)
+{}
+
+Condition_2::ResourceSupplyConnectedByEmpire::~ResourceSupplyConnectedByEmpire()
+{ delete m_condition; }
+
+namespace {
+    bool ResourceSupplySimpleMatch(const UniverseObject* candidate, int empire_id, const Condition_2::ObjectSet& from_objects) {
+        if (!candidate)
+            return false;
+        if (from_objects.empty())
+            return false;
+        const Empire* empire = Empires().Lookup(empire_id);
+        if (!empire)
+            return false;
+        const std::set<std::set<int> >& groups = empire->ResourceSupplyGroups();
+
+        // is candidate object connected to a subcondition matching object by resource supply?
+        for (Condition_2::ObjectSet::const_iterator it = from_objects.begin(); it != from_objects.end(); ++it) {
+            const UniverseObject* from_object(*it);
+
+            for (std::set<std::set<int> >::const_iterator groups_it = groups.begin(); groups_it != groups.end(); ++groups_it) {
+                const std::set<int>& group = *groups_it;
+                if (group.find(from_object->SystemID()) != group.end()) {
+                    // found resource sharing group containing test object.  Does it also contain candidate?
+                    if (group.find(candidate->SystemID()) != group.end())
+                        return true;    // test object and candidate object are in same resourse sharing group
+                    else
+                        return false;   // test object is not in resource sharing group with candidate (each object can be in only one group)
+                }
+                // current subcondition-matching object is not in this resource sharing group
+            }
+            // current subcondition-matching object is not in any resource sharing group for this empire
+        }
+
+        return false;
+    }
+}
+
+void Condition_2::ResourceSupplyConnectedByEmpire::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    bool simple_eval_safe = ValueRef_2::ConstantExpr(m_empire_id) ||
+                            (LocalCandidateInvariant(m_empire_id) &&
+                            (parent_context.condition_root_candidate || RootCandidateInvariant()));
+    if (simple_eval_safe) {
+        // evaluate contained objects once and check for all candidates
+        ObjectMap& objects = GetUniverse().Objects();
+
+        const UniverseObject* no_object(0);
+        ScriptingContext local_context(parent_context, no_object);
+
+        // get objects to be considering for matching against subcondition
+        ObjectSet subcondition_non_matches;
+        for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+            subcondition_non_matches.insert(it->second);
+        ObjectSet subcondition_matches;
+        m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+
+        int empire_id = m_empire_id->Eval(local_context);
+
+        ObjectSet& from_set = search_domain == MATCHES ? matches : non_matches;
+        ObjectSet& to_set = search_domain == MATCHES ? non_matches : matches;
+        ObjectSet::iterator it = from_set.begin();
+        ObjectSet::iterator end_it = from_set.end();
+        for ( ; it != end_it; ) {
+            ObjectSet::iterator temp = it++;
+            bool match = ResourceSupplySimpleMatch(*temp, empire_id, subcondition_matches);
+            if ((search_domain == MATCHES && !match) || (search_domain == NON_MATCHES && match)) {
+                to_set.insert(*temp);
+                from_set.erase(temp);
+            }
+        }
+
+    } else {
+        // re-evaluate empire id for each candidate object
+        Condition_2::ConditionBase::Eval(parent_context, matches, non_matches, search_domain);
+    }
+}
+
+bool Condition_2::ResourceSupplyConnectedByEmpire::RootCandidateInvariant() const
+{ return RootCandidateInvariant(m_empire_id) && m_condition->RootCandidateInvariant(); }
+
+bool Condition_2::ResourceSupplyConnectedByEmpire::TargetInvariant() const
+{ return TargetInvariant(m_empire_id) && m_condition->TargetInvariant(); }
+
+bool Condition_2::ResourceSupplyConnectedByEmpire::Match(const ScriptingContext& local_context) const
+{
+    const UniverseObject* candidate = local_context.condition_local_candidate;
+    if (!candidate) {
+        Logger().errorStream() << "ResourceSupplyConnectedByEmpire::Match passed no candidate object";
+        return false;
+    }
+
+    ObjectMap& objects = GetUniverse().Objects();
+
+    // get objects to be considering for matching against subcondition
+    ObjectSet subcondition_non_matches;
+    for (ObjectMap::iterator it = objects.begin(); it != objects.end(); ++it)
+        subcondition_non_matches.insert(it->second);
+    ObjectSet subcondition_matches;
+
+    m_condition->Eval(local_context, subcondition_matches, subcondition_non_matches);
+    int empire_id = m_empire_id->Eval(local_context);
+
+    return ResourceSupplySimpleMatch(candidate, empire_id, subcondition_matches);
+}
+
+std::string Condition_2::ResourceSupplyConnectedByEmpire::Description(bool negated/* = false*/) const
+{
+    std::string empire_str;
+    if (m_empire_id) {
+        int empire_id = ALL_EMPIRES;
+        if (ValueRef_2::ConstantExpr(m_empire_id))
+            empire_id = m_empire_id->Eval();
+        if (const Empire* empire = Empires().Lookup(empire_id))
+            empire_str = empire->Name();
+        else
+            empire_str = Description(m_empire_id);
+    }
+
+    std::string description_str = "DESC_SUPPLY_CONNECTED_RESOURCE";
+    if (negated)
+        description_str += "_NOT";
+
+    return str(FlexibleFormat(UserString(description_str))
+               % empire_str
+               % m_condition->Description());
+}
+->
+std::string Condition_2::ResourceSupplyConnectedByEmpire::Dump() const
+{
+    std::string retval = DumpIndent() + "ResourceSupplyConnectedByEmpire empire_id = " + Dump(m_empire_id) +
+                                        " condition = \n";
+    ++g_indent;
+    retval += m_condition->Dump();
+    --g_indent;
+    return retval;
+}
+
+///////////////////////////////////////////////////////////
+// And                                                   //
+///////////////////////////////////////////////////////////
+Condition_2::And::And(const std::vector<const ConditionBase*>& operands) :
+    m_operands(operands)
+{
+    assert(!m_operands.empty());
+}
+
+Condition_2::And::~And()
+{
+    for (unsigned int i = 0; i < m_operands.size(); ++i)
+        delete m_operands[i];
+}
+
+void Condition_2::And::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    const UniverseObject* no_object(0);
+    ScriptingContext local_context(parent_context, no_object);
+
+
+    if (search_domain == NON_MATCHES) {
+        ObjectSet partly_checked_non_matches;
+
+        // move items in non_matches set that pass first operand condition into
+        // partly_checked_non_targets set
+        m_operands[0]->Eval(local_context, partly_checked_non_matches, non_matches, NON_MATCHES);
+
+        // move items that don't pass one of the other conditions back to non_matches
+        for (unsigned int i = 1; i < m_operands.size(); ++i) {
+            if (partly_checked_non_matches.empty()) break;
+            m_operands[i]->Eval(local_context, partly_checked_non_matches, non_matches, MATCHES);
+        }
+
+        // merge items that passed all operand conditions into matches
+        matches.insert(partly_checked_non_matches.begin(), partly_checked_non_matches.end());
+
+        // items already in matches set are not checked, and remain in matches set even if
+        // they don't match one of the operand conditions
+
+    } else /*(search_domain == MATCHES)*/ {
+        // check all operand conditions on all objects in the matches set, moving those
+        // that don't pass a condition to the non-matches set
+
+        for (unsigned int i = 0; i < m_operands.size(); ++i) {
+            if (matches.empty()) break;
+            m_operands[i]->Eval(local_context, matches, non_matches, MATCHES);
+        }
+
+        // items already in non_matches set are not checked, and remain in non_matches set
+        // even if they pass all operand conditions
+    }
+}
+
+bool Condition_2::And::RootCandidateInvariant() const
+{
+    for (std::vector<const ConditionBase*>::const_iterator it = m_operands.begin(); it != m_operands.end(); ++it)
+        if (!RootCandidateInvariant(*it))
+            return false;
+    return true;
+}
+
+bool Condition_2::And::TargetInvariant() const
+{
+    for (std::vector<const ConditionBase*>::const_iterator it = m_operands.begin(); it != m_operands.end(); ++it)
+        if (!TargetInvariant(*it))
+            return false;
+    return true;
+}
+
+std::string Condition_2::And::Description(bool negated/* = false*/) const
+{
+    if (m_operands.size() == 1) {
+        return m_operands[0]->Description();
+    } else {
+        // TODO: use per-operand-type connecting language
+        std::string values_str;
+        for (unsigned int i = 0; i < m_operands.size(); ++i) {
+            values_str += m_operands[i]->Description();
+            if (i != m_operands.size() - 1) {
+                values_str += UserString("DESC_AND_BETWEEN_OPERANDS");
+            }
+        }
+        return values_str;
+    }
+}
+
+std::string Condition_2::And::Dump() const
+{
+    std::string retval = DumpIndent() + "And [\n";
+    ++g_indent;
+    for (unsigned int i = 0; i < m_operands.size(); ++i) {
+        retval += m_operands[i]->Dump();
+    }
+    --g_indent;
+    retval += "\n" + DumpIndent() + "]";
+    return retval;
+}
+
+///////////////////////////////////////////////////////////
+// Or                                                    //
+///////////////////////////////////////////////////////////
+Condition_2::Or::Or(const std::vector<const ConditionBase*>& operands) :
+    m_operands(operands)
+{
+    assert(!m_operands.empty());
+}
+
+Condition_2::Or::~Or()
+{
+    for (unsigned int i = 0; i < m_operands.size(); ++i)
+        delete m_operands[i];
+}
+
+void Condition_2::Or::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    const UniverseObject* no_object(0);
+    ScriptingContext local_context(parent_context, no_object);
+
+    if (search_domain == NON_MATCHES) {
+        // check each item in the non-matches set against each of the operand conditions
+        // if a non-candidate item matches an operand condition, move the item to the
+        // matches set.
+
+        for (unsigned int i = 0; i < m_operands.size(); ++i) {
+            if (non_matches.empty()) break;
+            m_operands[i]->Eval(local_context, matches, non_matches, NON_MATCHES);
+        }
+
+        // items already in matches set are not checked and remain in the
+        // matches set even if they fail all the operand conditions
+
+    } else {
+        ObjectSet partly_checked_matches;
+
+        // move items in matches set the fail the first operand condition into 
+        // partly_checked_targets set
+        m_operands[0]->Eval(local_context, matches, partly_checked_matches, MATCHES);
+
+        // move items that pass any of the other conditions back into matches
+        for (unsigned int i = 1; i < m_operands.size(); ++i) {
+            if (partly_checked_matches.empty()) break;
+            m_operands[i]->Eval(local_context, matches, partly_checked_matches, NON_MATCHES);
+        }
+
+        // merge items that failed all operand conditions into non_matches
+        non_matches.insert(partly_checked_matches.begin(), partly_checked_matches.end());
+
+        // items already in non_matches set are not checked and remain in
+        // non_matches set even if they pass one or more of the operand 
+        // conditions
+    }
+}
+
+bool Condition_2::Or::RootCandidateInvariant() const
+{
+    for (std::vector<const ConditionBase*>::const_iterator it = m_operands.begin(); it != m_operands.end(); ++it)
+        if (!RootCandidateInvariant(*it))
+            return false;
+    return true;
+}
+
+bool Condition_2::Or::TargetInvariant() const
+{
+    for (std::vector<const ConditionBase*>::const_iterator it = m_operands.begin(); it != m_operands.end(); ++it)
+        if (!TargetInvariant(*it))
+            return false;
+    return true;
+}
+
+std::string Condition_2::Or::Description(bool negated/* = false*/) const
+{
+    if (m_operands.size() == 1) {
+        return m_operands[0]->Description();
+    } else {
+        // TODO: use per-operand-type connecting language
+        std::string values_str;
+        for (unsigned int i = 0; i < m_operands.size(); ++i) {
+            values_str += m_operands[i]->Description();
+            if (i != m_operands.size() - 1) {
+                values_str += UserString("DESC_OR_BETWEEN_OPERANDS");
+            }
+        }
+        return values_str;
+    }
+}
+
+std::string Condition_2::Or::Dump() const
+{
+    std::string retval = DumpIndent() + "Or [\n";
+    ++g_indent;
+    for (unsigned int i = 0; i < m_operands.size(); ++i) {
+        retval += m_operands[i]->Dump();
+    }
+    --g_indent;
+    retval += "\n" + DumpIndent() + "]";
+    return retval;
+}
+
+///////////////////////////////////////////////////////////
+// Not                                                   //
+///////////////////////////////////////////////////////////
+Condition_2::Not::Not(const ConditionBase* operand) :
+    m_operand(operand)
+{
+    assert(m_operand);
+}
+
+Condition_2::Not::~Not()
+{
+    delete m_operand;
+}
+
+void Condition_2::Not::Eval(const ScriptingContext& parent_context, ObjectSet& matches, ObjectSet& non_matches, SearchDomain search_domain/* = NON_MATCHES*/) const
+{
+    const UniverseObject* no_object(0);
+    ScriptingContext local_context(parent_context, no_object);
+
+    if (search_domain == NON_MATCHES) {
+        // search non_matches set for items that don't meet the operand
+        // condition, and move those to the matches set
+        m_operand->Eval(local_context, non_matches, matches, MATCHES); // swapping order of matches and non_matches set parameters and MATCHES / NON_MATCHES search domain effects NOT on requested search domain
+    } else {
+        // search matches set for items that meet the operand condition
+        // condition, and move those to the non_matches set
+        m_operand->Eval(local_context, non_matches, matches, NON_MATCHES);
+    }
+}
+
+bool Condition_2::Not::RootCandidateInvariant() const
+{ return m_operand->RootCandidateInvariant(); }
+
+bool Condition_2::Not::TargetInvariant() const
+{ return m_operand->TargetInvariant(); }
+
+std::string Condition_2::Not::Description(bool negated/* = false*/) const
+{
+    return m_operand->Description(true);
+}
+
+std::string Condition_2::Not::Dump() const
+{
+    std::string retval = DumpIndent() + "Not\n";
+    ++g_indent;
+    retval += m_operand->Dump();
+    --g_indent;
+    return retval;
+}
Index: universe/Names.h
===================================================================
--- universe/Names.h	(revision 0)
+++ universe/Names.h	(revision 0)
@@ -0,0 +1,246 @@
+// -*- C++ -*-
+#ifndef _Names_h_
+#define _Names_h_
+
+#include <GG/adobe/name.hpp>
+
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/seq/for_each.hpp>
+
+
+#define NAMES_SEQ                               \
+    (Activation)                                \
+    (AddedBefore)                               \
+    (AddedSince)                                \
+    (AddSpecial)                                \
+    (AddStarlanes)                              \
+    (Affiliation)                               \
+    (Age)                                       \
+    (Alignment)                                 \
+    (All)                                       \
+    (And)                                       \
+    (AntiFighterDamage)                         \
+    (AntiShipDamage)                            \
+    (Armed)                                     \
+    (Asteroids)                                 \
+    (BattleSpeed)                               \
+    (BuildCost)                                 \
+    (Building)                                  \
+    (BuildingType)                              \
+    (BuildTime)                                 \
+    (CanColonize)                               \
+    (CanProduceShips)                           \
+    (Capacity)                                  \
+    (Capital)                                   \
+    (CaptureResult)                             \
+    (Category)                                  \
+    (Class)                                     \
+    (Colour)                                    \
+    (Condition)                                 \
+    (Construction)                              \
+    (ContainedBy)                               \
+    (Contains)                                  \
+    (CreateBuilding)                            \
+    (CreatedOnTurn)                             \
+    (CreatePlanet)                              \
+    (CreateShip)                                \
+    (CreationTurn)                              \
+    (CurrentTurn)                               \
+    (Damage)                                    \
+    (Data)                                      \
+    (Defense)                                   \
+    (Description)                               \
+    (Design)                                    \
+    (DesignHasHull)                             \
+    (DesignHasPart)                             \
+    (DesignHasPartClass)                        \
+    (DesignID)                                  \
+    (DesignName)                                \
+    (Destination)                               \
+    (Destroy)                                   \
+    (Detection)                                 \
+    (Distance)                                  \
+    (DistanceToSource)                          \
+    (Effects)                                   \
+    (EffectsGroup)                              \
+    (EffectsGroups)                             \
+    (Empire)                                    \
+    (Endpoint)                                  \
+    (Environment)                               \
+    (Environments)                              \
+    (ExploredByEmpire)                          \
+    (Farming)                                   \
+    (FighterType)                               \
+    (FighterWeaponRange)                        \
+    (FinalDestinationID)                        \
+    (Fleet)                                     \
+    (FleetID)                                   \
+    (FleetSupplyableByEmpire)                   \
+    (Foci)                                      \
+    (Focus)                                     \
+    (FocusType)                                 \
+    (FoodConsumption)                           \
+    (FoodStockpile)                             \
+    (Fuel)                                      \
+    (GasGiant)                                  \
+    (GenerateSitrepMessage)                     \
+    (GiveTechToOwner)                           \
+    (Graphic)                                   \
+    (HasSpecial)                                \
+    (HasSpecialSinceTurn)                       \
+    (Health)                                    \
+    (High)                                      \
+    (Homeworld)                                 \
+    (Hull)                                      \
+    (ID)                                        \
+    (Industry)                                  \
+    (InSystem)                                  \
+    (Item)                                      \
+    (Jumps)                                     \
+    (Label)                                     \
+    (LaunchRate)                                \
+    (LocalCandidate)                            \
+    (Location)                                  \
+    (LockTechItemsForOwner)                     \
+    (Lookup_Strings)                            \
+    (Low)                                       \
+    (MaxDefense)                                \
+    (MaxFuel)                                   \
+    (MaximumNumberOf)                           \
+    (MaxShield)                                 \
+    (MaxStructure)                              \
+    (MaxTroops)                                 \
+    (Message)                                   \
+    (Meter)                                     \
+    (MineralStockpile)                          \
+    (MinimumNumberOf)                           \
+    (Mining)                                    \
+    (Mode)                                      \
+    (Model)                                     \
+    (ModeNumberOf)                              \
+    (Monster)                                   \
+    (MonsterFleet)                              \
+    (MountableSlotTypes)                        \
+    (MoveTo)                                    \
+    (Name)                                      \
+    (NextBetterPlanetType)                      \
+    (NextSystemID)                              \
+    (Not)                                       \
+    (Number)                                    \
+    (NumberOf)                                  \
+    (NumShips)                                  \
+    (Object)                                    \
+    (ObjectType)                                \
+    (Or)                                        \
+    (OwnedBy)                                   \
+    (Owner)                                     \
+    (OwnerFoodStockpile)                        \
+    (OwnerHasTech)                              \
+    (OwnerMineralStockpile)                     \
+    (OwnerTradeStockpile)                       \
+    (Parameters)                                \
+    (Part)                                      \
+    (PartClass)                                 \
+    (PartName)                                  \
+    (Parts)                                     \
+    (Planet)                                    \
+    (Planetbound)                               \
+    (PlanetEnvironment)                         \
+    (PlanetID)                                  \
+    (PlanetSize)                                \
+    (PlanetType)                                \
+    (Playable)                                  \
+    (Population)                                \
+    (Position)                                  \
+    (Prerequisites)                             \
+    (PreviousSystemID)                          \
+    (Probability)                               \
+    (ProducedByEmpire)                          \
+    (ProducedByEmpireID)                        \
+    (Producible)                                \
+    (Property)                                  \
+    (Random)                                    \
+    (Range)                                     \
+    (Reason)                                    \
+    (RemoveSpecial)                             \
+    (RemoveStarlanes)                           \
+    (Research)                                  \
+    (Researchable)                              \
+    (ResearchCost)                              \
+    (ResearchTurns)                             \
+    (ResourceSupplyConnected)                   \
+    (RevokeTechFromOwner)                       \
+    (ROF)                                       \
+    (RootCandidate)                             \
+    (Scope)                                     \
+    (Set)                                       \
+    (SetDestination)                            \
+    (SetEmpireCapital)                          \
+    (SetEmpireFoodStockpile)                    \
+    (SetEmpireMeter)                            \
+    (SetEmpireMineralStockpile)                 \
+    (SetEmpireTradeStockpile)                   \
+    (SetOwner)                                  \
+    (SetPlanetSize)                             \
+    (SetPlanetType)                             \
+    (SetSpecies)                                \
+    (SetStarType)                               \
+    (Shield)                                    \
+    (Shipdesign)                                \
+    (Ships)                                     \
+    (Short_Description)                         \
+    (Size)                                      \
+    (Slot)                                      \
+    (Slots)                                     \
+    (SlotType)                                  \
+    (SortBy)                                    \
+    (SortKey)                                   \
+    (Source)                                    \
+    (Spacebound)                                \
+    (SpawnLimit)                                \
+    (SpawnRate)                                 \
+    (Special)                                   \
+    (Species)                                   \
+    (Speed)                                     \
+    (StackingGroup)                             \
+    (Star)                                      \
+    (StarlaneSpeed)                             \
+    (StarType)                                  \
+    (Stationary)                                \
+    (Stealth)                                   \
+    (Structure)                                 \
+    (Supply)                                    \
+    (System)                                    \
+    (SystemID)                                  \
+    (Tag)                                       \
+    (Target)                                    \
+    (TargetConstruction)                        \
+    (TargetFarming)                             \
+    (TargetHealth)                              \
+    (TargetIndustry)                            \
+    (TargetMining)                              \
+    (TargetPopulation)                          \
+    (TargetResearch)                            \
+    (TargetTrade)                               \
+    (Tech)                                      \
+    (TechType)                                  \
+    (Trade)                                     \
+    (TradeStockpile)                            \
+    (Troops)                                    \
+    (Turn)                                      \
+    (Type)                                      \
+    (Unlock)                                    \
+    (UnlockTechItemsForOwner)                   \
+    (Unproducible)                              \
+    (Unresearchable)                            \
+    (Value)                                     \
+    (Victory)                                   \
+    (VisibleToEmpire)                           \
+    (WithinDistance)                            \
+    (WithinStarlaneJumps)
+
+#define DECLARE_NAME(r, _, elem) extern adobe::aggregate_name_t BOOST_PP_CAT(elem, _name);
+BOOST_PP_SEQ_FOR_EACH(DECLARE_NAME, _, NAMES_SEQ)
+#undef DECLARE_NAME
+
+#endif
Index: universe/ValueRef_2.h
===================================================================
--- universe/ValueRef_2.h	(revision 0)
+++ universe/ValueRef_2.h	(revision 0)
@@ -0,0 +1,344 @@
+// -*- C++ -*-
+#ifndef _ValueRef_2_h_
+#define _ValueRef_2_h_
+
+#include "Enums.h"
+#include "ValueRefFwd_2.h"
+#if 0
+#include "Condition.h"
+#endif
+#include "Names.h"
+#include "../util/MultiplayerCommon.h"
+
+#include <GG/adobe/name.hpp>
+
+#include <boost/algorithm/string/case_conv.hpp>
+#include <boost/format.hpp>
+#include <boost/mpl/if.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/type_traits/is_enum.hpp>
+
+#include <string>
+#include <vector>
+#include <map>
+
+class UniverseObject;
+namespace boost {
+    class any;
+}
+
+struct ScriptingContext {
+    /** Empty context.  Useful for evaluating ValueRef::Constant that don't
+      * depend on their context. */
+    ScriptingContext();
+
+    /** Context with only a source object.  Useful for evaluating effectsgroup
+      * scope and activation conditions that have no external candidates or
+      * effect target to propegate. */
+    explicit ScriptingContext(const UniverseObject* source_);
+
+    ScriptingContext(const UniverseObject* source_, UniverseObject* target_);
+
+    ScriptingContext(const UniverseObject* source_, UniverseObject* target_,
+                     const boost::any& current_value_);
+
+    /** For evaluating ValueRef in an Effect::Execute function.  Keeps input
+      * context, but specifies the current value. */
+    ScriptingContext(const ScriptingContext& context,
+                     const boost::any& current_value_);
+
+    /** For recusrive evaluation of Conditions.  Keeps source and effect_target
+      * from input context, but sets local candidate with input object, and if
+      * there is no root candidate in the parent context, then the input object
+      * becomes the root candidate. */
+    ScriptingContext(const ScriptingContext& parent_context,
+                     const UniverseObject* condition_local_candidate);
+
+    ScriptingContext(const UniverseObject* source_, UniverseObject* target_,
+                     const boost::any& current_value_,
+                     const UniverseObject* condition_root_candidate_,
+                     const UniverseObject* condition_local_candidate_);
+
+    const UniverseObject*   source;
+    UniverseObject*         effect_target;
+    const UniverseObject*   condition_root_candidate;
+    const UniverseObject*   condition_local_candidate;
+    const boost::any        current_value;
+};
+
+namespace ValueRef_2 {
+
+    /** the constant value leaf ValueRef class. */
+    template <class T>
+    struct Constant
+    {
+        Constant(T value) : m_value(value) {}
+
+        T m_value;
+    };
+
+    /** The variable value ValueRef class.  The value returned by this node is
+        taken from either the \a source or \a target parameters to Eval. */
+    template <class T>
+    struct Variable
+    {
+        Variable(const std::vector<adobe::name_t>& property_name) :
+            m_ref_type(),
+            m_property_name(property_name.begin() + 1, property_name.end())
+            {
+                if (property_name.front() == Source_name)
+                    m_ref_type = SOURCE_REFERENCE;
+                else if (property_name.front() == Target_name)
+                    m_ref_type = EFFECT_TARGET_REFERENCE;
+                else if (property_name.front() == RootCandidate_name)
+                    m_ref_type = CONDITION_ROOT_CANDIDATE_REFERENCE;
+                else if (property_name.front() == LocalCandidate_name)
+                    m_ref_type = CONDITION_LOCAL_CANDIDATE_REFERENCE;
+                else
+                    throw std::runtime_error(std::string("Variable has an unrecognized first token ") + property_name.begin()->c_str());
+            }
+
+        ReferenceType                   m_ref_type;
+        std::vector<adobe::name_t>      m_property_name;
+    };
+
+#if 0 // TODO
+    /** The variable statistic class.  The value returned by this node is
+        computed from the general gamestate; the value of the indicated \a
+        property_name is computed for each object that matches \a
+        sampling_condition and the statistic indicated by \a stat_type is
+        calculated from them and returned. */
+    template <class T>
+    struct Statistic : public Variable<T>
+    {
+        Statistic(const std::string& property_name,
+                  StatisticType stat_type,
+                  const Condition::ConditionBase* sampling_condition);
+
+        StatisticType                   GetStatisticType() const;
+        const Condition::ConditionBase* SamplingCondition() const;
+
+        virtual T                       Eval(const ScriptingContext& context) const;
+
+        virtual bool                    RootCandidateInvariant() const;
+        virtual bool                    LocalCandidateInvariant() const;
+        virtual bool                    TargetInvariant() const;
+
+        virtual std::string             Description() const;
+        virtual std::string             Dump() const;
+
+    protected:
+        Statistic(const std::vector<std::string>& property_name,
+                  StatisticType stat_type,
+                  const Condition::ConditionBase* sampling_condition);
+
+        /** Gets the set of objects in the Universe that match the sampling condition. */
+        void    GetConditionMatches(const ScriptingContext& context,
+                                    Condition::ObjectSet& condition_targets,
+                                    const Condition::ConditionBase* condition) const;
+
+        /** Evaluates the property for the specified objects. */
+        void    GetObjectPropertyValues(const ScriptingContext& context,
+                                        const Condition::ObjectSet& objects,
+                                        std::map<const UniverseObject*, T>& object_property_values) const;
+
+        /** Computes the statistic from the specified set of property values. */
+        T       ReduceData(const std::map<const UniverseObject*, T>& object_property_values) const;
+
+    private:
+        StatisticType                   m_stat_type;
+        const Condition::ConditionBase* m_sampling_condition;
+
+        friend class boost::serialization::access;
+        template <class Archive>
+        void serialize(Archive& ar, const unsigned int version);
+    };
+#endif
+
+    /** The variable static_cast class.  The value returned by this node is
+        taken from the ctor \a value_ref parameter's FromType value,
+        static_cast to ToType. */
+    struct IntToDoubleStaticCast
+    {
+        IntToDoubleStaticCast(const Int& value_ref) : m_value_ref(value_ref) {}
+
+        Int m_value_ref;
+    };
+
+    /** The variable lexical_cast to string class.  The value returned by this
+        node is taken from the ctor \a value_ref parameter's FromType value,
+        lexical_cast to std::string */
+    template <class T>
+    struct LexicalCast
+    {
+        typedef typename detail::value_ref_type<T>::type variant_type;
+
+        LexicalCast(const variant_type& value_ref) : m_value_ref(value_ref) {}
+
+        variant_type m_value_ref;
+    };
+
+    /** An addition operation node ValueRef class. */
+    template <class T>
+    struct Addition
+    {
+        typedef typename detail::value_ref_type<T>::type variant_type;
+
+        Addition(const variant_type& operand1, const variant_type& operand2) :
+            m_operand1(operand1),
+            m_operand2(operand2)
+            {}
+
+        variant_type m_operand1;
+        variant_type m_operand2;
+    };
+
+    /** A subtraction operation node ValueRef class. */
+    template <class T>
+    struct Subtraction
+    {
+        typedef typename detail::value_ref_type<T>::type variant_type;
+
+        Subtraction(const variant_type& operand1, const variant_type& operand2) :
+            m_operand1(operand1),
+            m_operand2(operand2)
+            {}
+
+        variant_type m_operand1;
+        variant_type m_operand2;
+    };
+
+    /** A multiplication operation node ValueRef class. */
+    template <class T>
+    struct Multiplication
+    {
+        typedef typename detail::value_ref_type<T>::type variant_type;
+
+        Multiplication(const variant_type& operand1, const variant_type& operand2) :
+            m_operand1(operand1),
+            m_operand2(operand2)
+            {}
+
+        variant_type m_operand1;
+        variant_type m_operand2;
+    };
+
+    /** A division operation node ValueRef class. */
+    template <class T>
+    struct Division
+    {
+        typedef typename detail::value_ref_type<T>::type variant_type;
+
+        Division(const variant_type& operand1, const variant_type& operand2) :
+            m_operand1(operand1),
+            m_operand2(operand2)
+            {}
+
+        variant_type m_operand1;
+        variant_type m_operand2;
+    };
+
+    /** A negation operation node ValueRef class. */
+    template <class T>
+    struct Negation
+    {
+        typedef typename detail::value_ref_type<T>::type variant_type;
+
+        Negation(const variant_type& operand) : m_operand(operand) {}
+
+        variant_type m_operand;
+    };
+
+    namespace detail {
+
+        template <typename T>
+        T evaluate_variable(const Variable<T>& e, const ScriptingContext& context);
+
+        template <>
+        int evaluate_variable<int>(const Variable<int>& e, const ScriptingContext& context);
+
+        template <>
+        double evaluate_variable<double>(const Variable<double>& e, const ScriptingContext& context);
+
+        template <>
+        std::string evaluate_variable<std::string>(const Variable<std::string>& e, const ScriptingContext& context);
+
+        template <>
+        PlanetSize evaluate_variable<PlanetSize>(const Variable<PlanetSize>& e, const ScriptingContext& context);
+
+        template <>
+        PlanetType evaluate_variable<PlanetType>(const Variable<PlanetType>& e, const ScriptingContext& context);
+
+        template <>
+        PlanetEnvironment evaluate_variable<PlanetEnvironment>(const Variable<PlanetEnvironment>& e, const ScriptingContext& context);
+
+        template <>
+        UniverseObjectType evaluate_variable<UniverseObjectType>(const Variable<UniverseObjectType>& e, const ScriptingContext& context);
+
+        template <>
+        StarType evaluate_variable<StarType>(const Variable<StarType>& e, const ScriptingContext& context);
+
+        template <typename T>
+        struct evaluate_expr :
+            public boost::static_visitor<T>
+        {
+            evaluate_expr(const ScriptingContext& context) : m_context(&context) {}
+
+            T operator()(const Constant<T>& e) const
+                { return e.m_value; }
+            T operator()(const Variable<T>& e) const
+                { return evaluate_variable<T>(e, *m_context); }
+
+            double operator()(const IntToDoubleStaticCast& e) const
+                { return static_cast<double>(boost::apply_visitor(evaluate_expr<int>(), e)); }
+            std::string operator()(const LexicalCast<T>& e) const
+                { return boost::lexical_cast<std::string>(boost::apply_visitor(*this, e)); }
+
+            T operator()(const Addition<T>& e) const
+                { return boost::apply_visitor(*this, e.m_operand1) + boost::apply_visitor(*this, e.m_operand2); }
+            T operator()(const Subtraction<T>& e) const
+                { return boost::apply_visitor(*this, e.m_operand1) - boost::apply_visitor(*this, e.m_operand2); }
+            T operator()(const Multiplication<T>& e) const
+                { return boost::apply_visitor(*this, e.m_operand1) * boost::apply_visitor(*this, e.m_operand2); }
+            T operator()(const Division<T>& e) const
+                { return boost::apply_visitor(*this, e.m_operand1) / boost::apply_visitor(*this, e.m_operand2); }
+            T operator()(const Negation<T>& e) const
+                { return -boost::apply_visitor(*this, e.m_operand); }
+
+            const ScriptingContext* m_context;
+        };
+
+    }
+
+    template <typename T>
+    T Eval(const typename detail::value_ref_type<T>::type& value_ref, const ScriptingContext& context = ScriptingContext())
+    { return boost::apply_visitor(detail::evaluate_expr<T>(context), value_ref); }
+
+    template <typename T>
+    void Description(const typename detail::value_ref_type<T>::type& value_ref)
+    { /* TODO boost::apply_visitor(detail::describe_expr(), value_ref); */ }
+
+    template <typename T>
+    void Dump(const typename detail::value_ref_type<T>::type& value_ref)
+    { /* TODO boost::apply_visitor(detail::dump_expr(), value_ref); */ }
+
+    template <typename T>
+    bool TargetInvariant(const typename detail::value_ref_type<T>::type& value_ref)
+    { return true; /* TODO boost::apply_visitor(detail::target_invariant(), value_ref); */ }
+
+    template <typename T>
+    bool RootCandidateInvariant(const typename detail::value_ref_type<T>::type& value_ref)
+    { return true; /* TODO boost::apply_visitor(detail::root_candidate_invariant(), value_ref); */ }
+
+    template <typename T>
+    bool LocalCandidateInvariant(const typename detail::value_ref_type<T>::type& value_ref)
+    { return true; /* TODO boost::apply_visitor(detail::local_candidate_invariant(), value_ref); */ }
+
+}
+
+/** A function that returns the correct amount of spacing for the current
+  * indentation level during a dump.  Note that this function is used by
+  * several units (Condition.cpp, Effect.cpp, etc.), not just this one. */
+std::string DumpIndent();
+
+#endif
Index: universe/Names.cpp
===================================================================
--- universe/Names.cpp	(revision 0)
+++ universe/Names.cpp	(revision 0)
@@ -0,0 +1,8 @@
+#include "Names.h"
+
+#include <boost/preprocessor/stringize.hpp>
+
+
+#define DEFINE_NAME(r, _, name) adobe::aggregate_name_t BOOST_PP_CAT(name, _name) = { BOOST_PP_STRINGIZE(name) };
+BOOST_PP_SEQ_FOR_EACH(DEFINE_NAME, _, NAMES_SEQ)
+#undef DEFINE_NAME
Index: universe/ValueRefFwd_2.h
===================================================================
--- universe/ValueRefFwd_2.h	(revision 0)
+++ universe/ValueRefFwd_2.h	(revision 0)
@@ -0,0 +1,221 @@
+// -*- C++ -*-
+#ifndef _ValueRefFwd_2_h_
+#define _ValueRefFwd_2_h_
+
+#include <boost/variant.hpp>
+
+
+/** This namespace contains ValueRefBase and its subclasses.  The ValueRefBase
+  * subclasses represent expression trees that may be evaluated at various
+  * times, and which refer to both constant and variable values. */
+namespace ValueRef_2 {
+
+    enum ReferenceType {
+        INVALID_REFERENCE_TYPE = -1,
+        NON_OBJECT_REFERENCE,               // ValueRef::Variable is not evalulated on any specific object
+        SOURCE_REFERENCE,                   // ValueRef::Variable is evaluated on the source object
+        EFFECT_TARGET_REFERENCE,            // ValueRef::Variable is evaluated on the target object of an effect while it is being executed
+        CONDITION_LOCAL_CANDIDATE_REFERENCE,// ValueRef::Variable is evaluated on an object that is a candidate to be matched by a condition.  In a subcondition, this will reference the local candidate, and not the candidate of an enclosing condition.
+        CONDITION_ROOT_CANDIDATE_REFERENCE  // ValueRef::Variable is evaluated on an object that is a candidate to be matched by a condition.  In a subcondition, this will still reference the root candidate, and not the candidate of the local condition.
+    };
+
+    enum StatisticType {
+        COUNT,  // returns the number of objects matching the condition
+        SUM,    // returns the sum of the property values of all objects matching the condition
+        MEAN,   // returns the mean of the property values of all objects matching the condition
+        RMS,    // returns the sqrt of the mean of the squares of the property values of all objects matching the condition
+        MODE,   // returns the most common property value of objects matching the condition.  supported for non-numeric types such as enums.
+        MAX,    // returns the maximum value of the property amongst objects matching the condition
+        MIN,    // returns the minimum value of the property amongst objects matching the condition
+        SPREAD, // returns the (positive) difference between the maximum and minimum values of the property amongst objects matching the condition
+        STDEV,  // returns the standard deviation of the property values of all objects matching the condition
+        PRODUCT // returns the product of the property values of all objects matching the condition
+    };
+
+    template <class T>
+    struct Constant;
+    template <class T>
+    struct Variable;
+    template <class T>
+    struct Statistic;
+    struct IntToDoubleStaticCast;
+    template <class FromVariantType>
+    struct LexicalCast;
+    template <class T>
+    struct Addition;
+    template <class T>
+    struct Subtraction;
+    template <class T>
+    struct Multiplication;
+    template <class T>
+    struct Division;
+    template <class T>
+    struct Negation;
+
+    // NOTE: It is assumed in much of the supporting code that Constant<> is
+    // the first element of each variant type.  Please do not break this
+    // convention.
+
+    typedef boost::variant<
+        Constant<int>,
+        Variable<int>,
+        boost::recursive_wrapper<Addition<int> >,
+        boost::recursive_wrapper<Subtraction<int> >,
+        boost::recursive_wrapper<Multiplication<int> >,
+        boost::recursive_wrapper<Division<int> >,
+        boost::recursive_wrapper<Negation<int> >
+    > Int;
+
+    typedef boost::variant<
+        Constant<double>,
+        Variable<double>,
+        IntToDoubleStaticCast,
+        boost::recursive_wrapper<Addition<double> >,
+        boost::recursive_wrapper<Subtraction<double> >,
+        boost::recursive_wrapper<Multiplication<double> >,
+        boost::recursive_wrapper<Division<double> >,
+        boost::recursive_wrapper<Negation<double> >
+    > Double;
+
+    typedef boost::variant<
+        Constant<std::string>,
+        Variable<std::string>,
+        LexicalCast<int>,
+        LexicalCast<double>
+    > String;
+
+    template <typename T>
+    struct enum_value_ref
+    {
+        typedef boost::variant<
+            Constant<T>,
+            Variable<T>
+        > type;
+    };
+
+    typedef enum_value_ref<PlanetSize>::type PlanetSize;
+    typedef enum_value_ref<PlanetType>::type PlanetType;
+    typedef enum_value_ref<PlanetEnvironment>::type PlanetEnvironment;
+    typedef enum_value_ref<UniverseObjectType>::type UniverseObjectType;
+    typedef enum_value_ref<StarType>::type StarType;
+
+    namespace detail {
+
+        template <typename T>
+        struct value_ref_type;
+
+        template <>
+        struct value_ref_type<int>
+        { typedef Int type; };
+
+        template <>
+        struct value_ref_type<double>
+        { typedef Double type; };
+
+        template <>
+        struct value_ref_type<std::string>
+        { typedef String type; };
+
+        template <>
+        struct value_ref_type<PlanetSize>
+        { typedef PlanetSize type; };
+
+        template <>
+        struct value_ref_type<PlanetType>
+        { typedef PlanetType type; };
+
+        template <>
+        struct value_ref_type<PlanetEnvironment>
+        { typedef PlanetEnvironment type; };
+
+        template <>
+        struct value_ref_type<UniverseObjectType>
+        { typedef UniverseObjectType type; };
+
+        template <>
+        struct value_ref_type<StarType>
+        { typedef StarType type; };
+
+        struct const_expr :
+            public boost::static_visitor<bool>
+        {
+            template <typename T>
+            bool operator()(const T&) const
+                { return false; }
+
+            bool operator()(const Constant<int>&) const
+                { return true; }
+            bool operator()(const Constant<double>&) const
+                { return true; }
+            bool operator()(const Constant<std::string>&) const
+                { return true; }
+            bool operator()(const Constant<PlanetSize>&) const
+                { return true; }
+            bool operator()(const Constant<PlanetType>&) const
+                { return true; }
+            bool operator()(const Constant<PlanetEnvironment>&) const
+                { return true; }
+            bool operator()(const Constant<UniverseObjectType>&) const
+                { return true; }
+            bool operator()(const Constant<StarType>&) const
+                { return true; }
+        };
+
+        template <typename T>
+        struct optimize_expr :
+            public boost::static_visitor<typename detail::value_ref_type<T>::type>
+        {
+            typedef typename detail::value_ref_type<T>::type variant_type;
+
+            template <typename U>
+            variant_type operator()(const U& u) const
+                { return T(u); }
+
+#define BINARY_OPERATION(name, op)                                      \
+            variant_type operator()(const name<T>& e) const             \
+                {                                                       \
+                    const variant_type& op1 =                           \
+                        boost::apply_visitor(*this, e.m_operand1);      \
+                    const variant_type& op2 =                           \
+                        boost::apply_visitor(*this, e.m_operand2);      \
+                    if (!op1.which() && !op2.which()) {                 \
+                        return variant_type(                            \
+                            Constant<T>(                                \
+                                boost::get<Constant<T> >(op1).m_value   \
+                                op                                      \
+                                boost::get<Constant<T> >(op2).m_value   \
+                            )                                           \
+                        );                                              \
+                    } else {                                            \
+                        return variant_type(name<T>(op1, op2));         \
+                    }                                                   \
+                }
+
+            BINARY_OPERATION(Addition, +)
+            BINARY_OPERATION(Subtraction, -)
+            BINARY_OPERATION(Multiplication, *)
+            BINARY_OPERATION(Division, /)
+
+            variant_type operator()(const Negation<T>& e) const
+                {
+                    const variant_type& op = boost::apply_visitor(*this, e.m_operand);
+                    if (!op.which())
+                        return variant_type(Constant<T>(-boost::get<Constant<T> >(op)).m_value);
+                    else
+                        return variant_type(Negation<T>(op));
+                }
+        };
+
+    }
+
+    template <class T>
+    bool ConstantExpr(const boost::variant<T>& expr)
+    { return boost::apply_visitor(detail::const_expr(), expr); }
+
+    template <class T>
+    typename detail::value_ref_type<T>::type OptimizeExpr(const typename detail::value_ref_type<T>::type& expr)
+    { return boost::apply_visitor(detail::optimize_expr<T>(), expr); }
+
+}
+
+#endif
Index: universe/Condition_2.h
===================================================================
--- universe/Condition_2.h	(revision 0)
+++ universe/Condition_2.h	(revision 0)
@@ -0,0 +1,1615 @@
+// -*- C++ -*-
+#ifndef _Condition_2_h_
+#define _Condition_2_h_
+
+#include "Enums.h"
+#include "ValueRefFwd_2.h"
+
+#include <boost/serialization/access.hpp>
+#include <boost/serialization/nvp.hpp>
+
+#include <set>
+#include <string>
+#include <vector>
+
+class UniverseObject;
+struct ScriptingContext;
+
+/** this namespace holds ConditionBase and its subclasses; these classes
+  * represent predicates about UniverseObjects used by, for instance, the
+  * Effect system. */
+namespace Condition_2 {
+    typedef std::set<const UniverseObject*> ObjectSet;
+
+    enum SearchDomain {
+        NON_MATCHES,    ///< The Condition will only examine items in the non matches set; those that match the Condition will be inserted into the matches set.
+        MATCHES         ///< The Condition will only examine items in the matches set; those that do not match the Condition will be inserted into the nonmatches set.
+    };
+
+    enum SortingMethod {
+        SORT_MAX,       ///< Objects with the largest sort key will be selected
+        SORT_MIN,       ///< Objects with the smallest sort key will be selected
+        SORT_MODE,      ///< Objects with the most common sort key will be selected
+        SORT_RANDOM     ///< Objects will be selected randomly, without consideration of property values
+    };
+
+    struct ConditionBase;
+    struct All;
+    struct EmpireAffiliation;
+    struct Source;
+    struct RootCandidate;
+    struct Target;
+    struct Homeworld;
+    struct Capital;
+    struct Monster;
+    struct Armed;
+    struct Type;
+    struct Building;
+    struct HasSpecial;
+    struct Contains;
+    struct PlanetSize;
+    struct PlanetType;
+    struct PlanetEnvironment;
+    struct Species;
+    struct FocusType;
+    struct StarType;
+    struct DesignHasHull;
+    struct DesignHasPart;
+    struct DesignHasPartClass;
+    struct PredefinedShipDesign;
+    struct NumberedShipDesign;
+    struct ProducedByEmpire;
+    struct Chance;
+    struct MeterValue;
+    struct EmpireStockpileValue;
+    struct OwnerHasTech;
+    struct VisibleToEmpire;
+    struct WithinDistance;
+    struct WithinStarlaneJumps;
+    struct CanAddStarlaneConnection;
+    struct CanRemoveStarlaneConnection;
+    struct ExploredByEmpire;
+    struct Stationary;
+    struct FleetSupplyableByEmpire;
+    struct ResourceSupplyConnectedByEmpire;
+    struct And;
+    struct Or;
+    struct Not;
+    struct Turn;
+    struct ContainedBy;
+    struct Number;
+    struct SortedNumberOf;
+    struct InSystem;
+    struct ObjectID;
+    struct CreatedOnTurn;
+}
+
+/** The base class for all Condition_2. */
+struct Condition_2::ConditionBase
+{
+    ConditionBase();
+    virtual ~ConditionBase();
+    virtual void        Eval(const ScriptingContext& parent_context,
+                             Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const;
+
+    /** Matches with an empty ScriptingContext */
+    void                Eval(Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const;
+
+    /** Returns true iff this condition's evaluation does not reference
+      * the RootCandidate objects.  This requirement ensures that if this
+      * condition is a subcondition to another Condition or a ValueRef, this
+      * condition may be evaluated once and its result used to match all local
+      * candidates to that condition. */
+    virtual bool        RootCandidateInvariant() const { return false; }
+
+    /** (Almost) all conditions are varying with local candidates; this is the
+      * point of evaluating a condition.  This funciton is provided for
+      * consistency with ValueRef, which may not depend on the local candidiate
+      * of an enclosing condition. */
+    bool                LocalCandidateInvariant() const { return false; }
+
+    /** Returns true iff this condition's evaluation does not reference the
+      * target object.*/
+    virtual bool        TargetInvariant() const { return false; }
+
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects if the number of objects that match Condition
+  * \a condition is is >= \a low and < \a high.  Matched objects may
+  * or may not themselves match the condition. */
+struct Condition_2::Number : public Condition_2::ConditionBase
+{
+    Number(const ValueRef_2::Int& low, const ValueRef_2::Int& high, const ConditionBase* condition);
+    virtual ~Number();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    const ValueRef_2::Int& m_low;
+    const ValueRef_2::Int& m_high;
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects if the current game turn is >= \a low and < \a high. */
+struct Condition_2::Turn : public Condition_2::ConditionBase
+{
+    Turn(const ValueRef_2::Int& low, const ValueRef_2::Int& high);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ValueRef_2::Int& m_low;
+    const ValueRef_2::Int& m_high;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches a specified \a number of objects that match Condition \a condition
+  * or as many objects as match the condition if the number of objects is less
+  * than the number requested.  If more objects match the condition than are
+  * requested, the objects are sorted according to the value of the specified
+  * \a property_name and objects are matched according to whether they have
+  * the specified \a sorting_type of those property values.  For example,
+  * objects with the largest, smallest or most common property value may be
+  * selected preferentially. */
+struct Condition_2::SortedNumberOf : public Condition_2::ConditionBase
+{
+    /** Sorts randomly, without considering a sort key. */
+    SortedNumberOf(const ValueRef_2::Int& number,
+                   const ConditionBase* condition);
+
+    /** Sorts according to the specified method, based on the key values
+      * evaluated for each object. */
+    SortedNumberOf(const ValueRef_2::Int& number,
+                   const ValueRef_2::Double& sort_key_ref,
+                   SortingMethod sorting_method,
+                   const ConditionBase* condition);
+
+    virtual ~SortedNumberOf();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    const ValueRef_2::Int&    m_number;
+    const ValueRef_2::Double& m_sort_key;
+    SortingMethod           m_sorting_method;
+    const ConditionBase*    m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects. */
+struct Condition_2::All : public Condition_2::ConditionBase
+{
+    All();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are owned (if \a exclusive == false) or only owned
+  * (if \a exclusive == true) by an empire that has affilitation type
+  * \a affilitation with Empire \a empire_id. */
+struct Condition_2::EmpireAffiliation : public Condition_2::ConditionBase
+{
+    EmpireAffiliation(const ValueRef_2::Int& empire_id, EmpireAffiliationType affiliation);
+    EmpireAffiliation(EmpireAffiliationType affiliation);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int         m_empire_id;
+    EmpireAffiliationType m_affiliation;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches the source object only. */
+struct Condition_2::Source : public Condition_2::ConditionBase
+{
+    Source();
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches the root candidate object in a condition tree.  This is useful
+  * within a subcondition to match the object actually being matched by the
+  * whole compound condition, rather than an object just being matched in a
+  * subcondition in order to evaluate the outer condition. */
+struct Condition_2::RootCandidate : public Condition_2::ConditionBase
+{
+    RootCandidate();
+    virtual bool        RootCandidateInvariant() const { return false; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** There is no LocalCandidate condition.  To match any local candidate object,
+  * use the All condition. */
+
+/** Matches the target of an effect being executed. */
+struct Condition_2::Target : public Condition_2::ConditionBase
+{
+    Target();
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return false; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches planets that are a homeworld for any of the species specified in
+  * \a names.  If \a names is empty, matches any planet that is a homeworld for
+  * any species in the current game Universe. */
+struct Condition_2::Homeworld : public Condition_2::ConditionBase
+{
+    Homeworld();
+    Homeworld(const std::vector<ValueRef_2::String>& names);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::String> m_names;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches planets that are an empire's capital. */
+struct Condition_2::Capital : public Condition_2::ConditionBase
+{
+    Capital();
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches space monsters. */
+struct Condition_2::Monster : public Condition_2::ConditionBase
+{
+    Monster();
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches armed ships and monsters. */
+struct Condition_2::Armed : public Condition_2::ConditionBase
+{
+    Armed();
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are of UniverseObjectType \a type. */
+struct Condition_2::Type : public Condition_2::ConditionBase
+{
+    Type(const ValueRef_2::UniverseObjectType& type);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::UniverseObjectType m_type;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all Building objects that are one of the building types specified
+  * in \a names. */
+struct Condition_2::Building : public Condition_2::ConditionBase
+{
+    Building(const std::vector<ValueRef_2::String>& names);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::String> m_names;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that have an attached Special named \a name. */
+struct Condition_2::HasSpecial : public Condition_2::ConditionBase
+{
+    HasSpecial(const std::string& name);
+    HasSpecial(const std::string& name, const ValueRef_2::Int& since_turn_low,
+               const ValueRef_2::Int& since_turn_high);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::string          m_name;
+    const ValueRef_2::Int& m_since_turn_low;
+    const ValueRef_2::Int& m_since_turn_high;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that were created on turns within the specified range. */
+struct Condition_2::CreatedOnTurn : public Condition_2::ConditionBase
+{
+    CreatedOnTurn(const ValueRef_2::Int& low, const ValueRef_2::Int& high);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ValueRef_2::Int& m_low;
+    const ValueRef_2::Int& m_high;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that contain an object that matches Condition
+  * \a condition.  Container objects are Systems, Planets (which contain
+  * Buildings), and Fleets (which contain Ships). */
+struct Condition_2::Contains : public Condition_2::ConditionBase
+{
+    Contains(const ConditionBase* condition);
+    virtual ~Contains();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are contained by an object that matches Condition
+  * \a condition.  Container objects are Systems, Planets (which contain
+  * Buildings), and Fleets (which contain Ships). */
+struct Condition_2::ContainedBy : public Condition_2::ConditionBase
+{
+    ContainedBy(const ConditionBase* condition);
+    virtual ~ContainedBy();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are in the system with the indicated \a system_id */
+struct Condition_2::InSystem : public Condition_2::ConditionBase
+{
+    InSystem(const ValueRef_2::Int& system_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_system_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches the object with the id \a object_id */
+struct Condition_2::ObjectID : public Condition_2::ConditionBase
+{
+    ObjectID(const ValueRef_2::Int& object_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_object_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all Planet objects that have one of the PlanetTypes in \a types.
+  * Note that all Building objects which are on matching planets are also
+  * matched. */
+struct Condition_2::PlanetType : public Condition_2::ConditionBase
+{
+    PlanetType(const std::vector<ValueRef_2::PlanetType>& types);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::PlanetType> m_types;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all Planet objects that have one of the PlanetSizes in \a sizes.
+  * Note that all Building objects which are on matching planets are also
+  * matched. */
+struct Condition_2::PlanetSize : public Condition_2::ConditionBase
+{
+    PlanetSize(const std::vector<ValueRef_2::PlanetSize>& sizes);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::PlanetSize> m_sizes;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all Planet objects that have one of the PlanetEnvironments in \a environments.  Note that all
+    Building objects which are on matching planets are also matched. */
+struct Condition_2::PlanetEnvironment : public Condition_2::ConditionBase
+{
+    PlanetEnvironment(const std::vector<ValueRef_2::PlanetEnvironment>& environments);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::PlanetEnvironment> m_environments;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all planets or ships that have one of the species in \a species.
+  * Note that all Building object which are on matching planets are also
+  * matched. */
+struct Condition_2::Species : public Condition_2::ConditionBase
+{
+    Species(const std::vector<ValueRef_2::String>& names);
+    Species();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::String> m_names;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all ProdCenter objects that have one of the FocusTypes in \a foci. */
+struct Condition_2::FocusType : public Condition_2::ConditionBase
+{
+    FocusType(const std::vector<ValueRef_2::String>& names);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::String> m_names;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all System objects that have one of the StarTypes in \a types.  Note that all objects
+    in matching Systems are also matched (Ships, Fleets, Buildings, Planets, etc.). */
+struct Condition_2::StarType : public Condition_2::ConditionBase
+{
+    StarType(const std::vector<ValueRef_2::StarType>& types);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::vector<ValueRef_2::StarType> m_types;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all ships whose ShipDesign has the hull specified by \a name. */
+struct Condition_2::DesignHasHull : public Condition_2::ConditionBase
+{
+    DesignHasHull(const std::string& name);
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::string m_name;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all ships whose ShipDesign has >= \a low and < \a high of the ship
+  * part specified by \a name. */
+struct Condition_2::DesignHasPart : public Condition_2::ConditionBase
+{
+    DesignHasPart(const ValueRef_2::Int& low, const ValueRef_2::Int& high, const std::string& name);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ValueRef_2::Int& m_low;
+    const ValueRef_2::Int& m_high;
+    std::string          m_name;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches ships whose ShipDesign has >= \a low and < \a high of ship parts of
+  * the specified \a part_class */
+struct Condition_2::DesignHasPartClass : public Condition_2::ConditionBase
+{
+    DesignHasPartClass(const ValueRef_2::Int& low, const ValueRef_2::Int& high, ShipPartClass part_class);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ValueRef_2::Int& m_low;
+    const ValueRef_2::Int& m_high;
+    ShipPartClass        m_class;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches ships who ShipDesign is a predefined shipdesign with the name
+  * \a name */
+struct Condition_2::PredefinedShipDesign : public Condition_2::ConditionBase
+{
+    PredefinedShipDesign(const std::string& name);
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::string m_name;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches ships whose design id \a id. */
+struct Condition_2::NumberedShipDesign : public Condition_2::ConditionBase
+{
+    NumberedShipDesign(const ValueRef_2::Int& design_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_design_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches ships or buildings produced by the empire with id \a empire_id.*/
+struct Condition_2::ProducedByEmpire : public Condition_2::ConditionBase
+{
+    ProducedByEmpire(const ValueRef_2::Int& empire_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_empire_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches a given object with a linearly distributed probability of \a chance. */
+struct Condition_2::Chance : public Condition_2::ConditionBase
+{
+    Chance(const ValueRef_2::Double& chance);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Double m_chance;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that have a meter of type \a meter, and whose current
+  * value is >= \a low and < \a high. */
+struct Condition_2::MeterValue : public Condition_2::ConditionBase
+{
+    MeterValue(MeterType meter, const ValueRef_2::Double& low, const ValueRef_2::Double& high);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    MeterType        m_meter;
+    ValueRef_2::Double m_low;
+    ValueRef_2::Double m_high;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects with exactly one owner, whose owner's stockpile of
+  * \a stockpile is between \a low and \a high, inclusive. */
+struct Condition_2::EmpireStockpileValue : public Condition_2::ConditionBase
+{
+    EmpireStockpileValue(ResourceType stockpile, const ValueRef_2::Double& low, const ValueRef_2::Double& high);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ResourceType     m_stockpile;
+    ValueRef_2::Double m_low;
+    ValueRef_2::Double m_high;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that have a single owner who has tech \a tech_name. */
+struct Condition_2::OwnerHasTech : public Condition_2::ConditionBase
+{
+    OwnerHasTech(const std::string& name);
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    std::string m_name;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are visible to at least one Empire in \a empire_ids. */
+struct Condition_2::VisibleToEmpire : public Condition_2::ConditionBase
+{
+    VisibleToEmpire(const ValueRef_2::Int& empire_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_empire_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are within \a distance units of at least one
+  * object that meets \a condition.  Warning: this Condition can slow things
+  * down considerably if overused.  It is best to use Condition_2 that yield
+  * relatively few matches. */
+struct Condition_2::WithinDistance : public Condition_2::ConditionBase
+{
+    WithinDistance(const ValueRef_2::Double& distance, const ConditionBase* condition);
+    virtual ~WithinDistance();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Double     m_distance;
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that are within \a jumps starlane jumps of at least one
+  * object that meets \a condition.  Warning: this Condition can slow things
+  * down considerably if overused.  It is best to use Condition_2 that yield
+  * relatively few matches. */
+struct Condition_2::WithinStarlaneJumps : public Condition_2::ConditionBase
+{
+    WithinStarlaneJumps(const ValueRef_2::Int& jumps, const ConditionBase* condition);
+    virtual ~WithinStarlaneJumps();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int        m_jumps;
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches objects that are in systems that could have starlanes added between
+  * them and all (not just one) of the systems containing (or that are) one of
+  * the objects matched by \a condition.  "Could have starlanes added" means
+  * that a lane would be geometrically acceptable, meaning it wouldn't cross
+  * any other lanes, pass too close to another system, or be too close in angle
+  * to an existing lane. */
+struct Condition_2::CanAddStarlaneConnection :  Condition_2::ConditionBase
+{
+    CanAddStarlaneConnection(const ConditionBase* condition);
+    virtual ~CanAddStarlaneConnection();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches objects that are in systems that could have starlanes removed from
+  * between them and all (not just one) of the systems containing (or that are)
+  * one of the objects matched by \a condition.  "Could have starlanes removed"
+  * means there is a lane between those systems, and that removing that lane
+  * will not break starlane-network connectivity between the systems on either
+  * end of the lane. */
+struct Condition_2::CanRemoveStarlaneConnection :  Condition_2::ConditionBase
+{
+    CanRemoveStarlaneConnection(const ConditionBase* condition);
+    virtual ~CanRemoveStarlaneConnection();
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches systems that have been explored by at least one Empire
+  * in \a empire_ids. */
+struct Condition_2::ExploredByEmpire : public Condition_2::ConditionBase
+{
+    ExploredByEmpire(const ValueRef_2::Int& empire_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_empire_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches objects that are moving. ... What does that mean?  Departing this
+  * turn, or were located somewhere else last turn...? */
+struct Condition_2::Stationary : public Condition_2::ConditionBase
+{
+    Stationary();
+    virtual bool        RootCandidateInvariant() const { return true; }
+    virtual bool        TargetInvariant() const { return true; }
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches objects that are in systems that can be fleet supplied by the
+  * empire with id \a empire_id */
+struct Condition_2::FleetSupplyableByEmpire : public Condition_2::ConditionBase
+{
+    FleetSupplyableByEmpire(const ValueRef_2::Int& empire_id);
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int m_empire_id;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches objects that are in systems that are connected by resource-sharing
+  * to at least one object that meets \a condition using the resource-sharing
+  * network of the empire with id \a empire_id */
+struct Condition_2::ResourceSupplyConnectedByEmpire : public Condition_2::ConditionBase
+{
+    ResourceSupplyConnectedByEmpire(const ValueRef_2::Int& empire_id, const ConditionBase* condition);
+    virtual ~ResourceSupplyConnectedByEmpire();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    virtual bool        Match(const ScriptingContext& local_context) const;
+
+    ValueRef_2::Int        m_empire_id;
+    const ConditionBase* m_condition;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that match every Condition in \a operands. */
+struct Condition_2::And : public Condition_2::ConditionBase
+{
+    And(const std::vector<const ConditionBase*>& operands);
+    virtual ~And();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    std::vector<const ConditionBase*> m_operands;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that match at least one Condition in \a operands. */
+struct Condition_2::Or : public Condition_2::ConditionBase
+{
+    Or(const std::vector<const ConditionBase*>& operands);
+    virtual ~Or();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    std::vector<const ConditionBase*> m_operands;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+/** Matches all objects that do not match the Condition \a operand. */
+struct Condition_2::Not : public Condition_2::ConditionBase
+{
+    Not(const ConditionBase* operand);
+    virtual ~Not();
+    virtual void        Eval(const ScriptingContext& parent_context, Condition_2::ObjectSet& matches,
+                             Condition_2::ObjectSet& non_matches, SearchDomain search_domain = NON_MATCHES) const;
+    void                Eval(Condition_2::ObjectSet& matches, Condition_2::ObjectSet& non_matches,
+                             SearchDomain search_domain = NON_MATCHES) const { ConditionBase::Eval(matches, non_matches, search_domain); }
+    virtual bool        RootCandidateInvariant() const;
+    virtual bool        TargetInvariant() const;
+    virtual std::string Description(bool negated = false) const;
+    virtual std::string Dump() const;
+
+private:
+    const ConditionBase* m_operand;
+
+    friend class boost::serialization::access;
+    template <class Archive>
+    void serialize(Archive& ar, const unsigned int version);
+};
+
+// template implementations
+template <class Archive>
+void Condition_2::ConditionBase::serialize(Archive& ar, const unsigned int version)
+{}
+
+template <class Archive>
+void Condition_2::Number::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::Turn::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high);
+}
+
+template <class Archive>
+void Condition_2::SortedNumberOf::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_number)
+        & BOOST_SERIALIZATION_NVP(m_sort_key)
+        & BOOST_SERIALIZATION_NVP(m_sorting_method)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::All::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::EmpireAffiliation::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_empire_id)
+        & BOOST_SERIALIZATION_NVP(m_affiliation);
+}
+
+template <class Archive>
+void Condition_2::Source::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::RootCandidate::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::Target::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::Homeworld::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_names);
+}
+
+template <class Archive>
+void Condition_2::Capital::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::Monster::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::Armed::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::Type::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_type);
+}
+
+template <class Archive>
+void Condition_2::Building::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_names);
+}
+
+template <class Archive>
+void Condition_2::HasSpecial::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_name)
+        & BOOST_SERIALIZATION_NVP(m_since_turn_low)
+        & BOOST_SERIALIZATION_NVP(m_since_turn_high);
+}
+
+template <class Archive>
+void Condition_2::CreatedOnTurn::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high);
+}
+
+template <class Archive>
+void Condition_2::Contains::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::ContainedBy::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::InSystem::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_system_id);
+}
+
+template <class Archive>
+void Condition_2::ObjectID::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_object_id);
+}
+
+template <class Archive>
+void Condition_2::PlanetType::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_types);
+}
+
+template <class Archive>
+void Condition_2::PlanetSize::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_sizes);
+}
+
+template <class Archive>
+void Condition_2::PlanetEnvironment::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_environments);
+}
+
+template <class Archive>
+void Condition_2::Species::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_names);
+}
+
+template <class Archive>
+void Condition_2::FocusType::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_names);
+}
+
+template <class Archive>
+void Condition_2::StarType::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_types);
+}
+
+template <class Archive>
+void Condition_2::DesignHasHull::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_name);
+}
+
+template <class Archive>
+void Condition_2::DesignHasPart::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high)
+        & BOOST_SERIALIZATION_NVP(m_name);
+}
+
+template <class Archive>
+void Condition_2::DesignHasPartClass::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high)
+        & BOOST_SERIALIZATION_NVP(m_class);
+}
+
+template <class Archive>
+void Condition_2::PredefinedShipDesign::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_name);
+}
+
+template <class Archive>
+void Condition_2::NumberedShipDesign::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_design_id);
+}
+
+template <class Archive>
+void Condition_2::ProducedByEmpire::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_empire_id);
+}
+
+template <class Archive>
+void Condition_2::Chance::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_chance);
+}
+
+template <class Archive>
+void Condition_2::MeterValue::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_meter)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high);
+}
+
+template <class Archive>
+void Condition_2::EmpireStockpileValue::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_low)
+        & BOOST_SERIALIZATION_NVP(m_high);
+}
+
+template <class Archive>
+void Condition_2::OwnerHasTech::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_name);
+}
+
+template <class Archive>
+void Condition_2::VisibleToEmpire::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_empire_id);
+}
+
+template <class Archive>
+void Condition_2::WithinDistance::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_distance)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::WithinStarlaneJumps::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_jumps)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::CanAddStarlaneConnection::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::CanRemoveStarlaneConnection::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::ExploredByEmpire::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_empire_id);
+}
+
+template <class Archive>
+void Condition_2::Stationary::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase);
+}
+
+template <class Archive>
+void Condition_2::FleetSupplyableByEmpire::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_empire_id);
+}
+
+template <class Archive>
+void Condition_2::ResourceSupplyConnectedByEmpire::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_empire_id)
+        & BOOST_SERIALIZATION_NVP(m_condition);
+}
+
+template <class Archive>
+void Condition_2::And::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_operands);
+}
+
+template <class Archive>
+void Condition_2::Or::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_operands);
+}
+
+template <class Archive>
+void Condition_2::Not::serialize(Archive& ar, const unsigned int version)
+{
+    ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConditionBase)
+        & BOOST_SERIALIZATION_NVP(m_operand);
+}
+
+#endif
Index: universe/ValueRef.h
===================================================================
--- universe/ValueRef.h	(revision 4423)
+++ universe/ValueRef.h	(working copy)
@@ -7,6 +7,8 @@
 #include "Condition.h"
 #include "../util/MultiplayerCommon.h"
 
+#include <GG/adobe/name.hpp>
+
 #include <boost/algorithm/string/case_conv.hpp>
 #include <boost/format.hpp>
 #include <boost/mpl/if.hpp>
@@ -130,6 +132,8 @@
       * otherwise, the same field is read from Eval's \a target parameter. */
     Variable(ReferenceType ref_type, const std::string& property_name);
 
+    Variable(const std::vector<adobe::name_t>& property_name) {}
+
     ReferenceType                   GetReferenceType() const;
     const std::vector<std::string>& PropertyName() const;
 
@@ -166,6 +170,12 @@
               StatisticType stat_type,
               const Condition::ConditionBase* sampling_condition);
 
+    Statistic(const std::vector<adobe::name_t>& property_name,
+              StatisticType stat_type,
+              const Condition::ConditionBase* sampling_condition) :
+        ValueRef::Variable<T>(property_name)
+        {}
+
     StatisticType                   GetStatisticType() const;
     const Condition::ConditionBase* SamplingCondition() const;
 
Index: universe/ValueRefFwd.h
===================================================================
--- universe/ValueRefFwd.h	(revision 4423)
+++ universe/ValueRefFwd.h	(working copy)
@@ -19,6 +19,7 @@
     template <class T> struct Variable;
     template <class T> struct Statistic;
     enum StatisticType {
+        INVALID_STATISTIC_TYPE = -1,
         COUNT,  // returns the number of objects matching the condition
         SUM,    // returns the sum of the property values of all objects matching the condition
         MEAN,   // returns the mean of the property values of all objects matching the condition
Index: universe/Tech.h
===================================================================
--- universe/Tech.h	(revision 4423)
+++ universe/Tech.h	(working copy)
@@ -141,7 +141,7 @@
     given a set of currently-known techs. */
 class TechManager
 {
-private:
+public:
     struct CategoryIndex {};
     struct NameIndex {};
     typedef boost::multi_index_container<
@@ -166,7 +166,6 @@
         >
     > TechContainer;
 
-public:
     /** iterator that runs over techs within a category */
     typedef TechContainer::index<CategoryIndex>::type::const_iterator category_iterator;
 
Index: universe/ValueRef_2.cpp
===================================================================
--- universe/ValueRef_2.cpp	(revision 0)
+++ universe/ValueRef_2.cpp	(revision 0)
@@ -0,0 +1,470 @@
+#include "ValueRef_2.h"
+
+#include "Names.h"
+#include "Building.h"
+#include "Fleet.h"
+#include "Planet.h"
+#include "System.h"
+#include "../Empire/Empire.h"
+#include "../Empire/EmpireManager.h"
+
+
+namespace {
+
+    const UniverseObject* FollowReference(std::vector<adobe::name_t>::const_iterator first,
+                                          std::vector<adobe::name_t>::const_iterator last,
+                                          ValueRef_2::ReferenceType ref_type,
+                                          const ScriptingContext& context)
+    {
+        const UniverseObject* obj(0);
+        switch (ref_type) {
+        case ValueRef_2::INVALID_REFERENCE_TYPE:
+        case ValueRef_2::NON_OBJECT_REFERENCE:
+            return 0;
+        case ValueRef_2::SOURCE_REFERENCE:                    obj = context.source;                    break;
+        case ValueRef_2::EFFECT_TARGET_REFERENCE:             obj = context.effect_target;             break;
+        case ValueRef_2::CONDITION_LOCAL_CANDIDATE_REFERENCE: obj = context.condition_local_candidate; break;
+        case ValueRef_2::CONDITION_ROOT_CANDIDATE_REFERENCE:  obj = context.condition_root_candidate;  break;
+        }
+
+        const ObjectMap& objects = GetMainObjectMap();
+        while (first != last) {
+            adobe::name_t property_name = *first;
+            if (property_name == Planet_name) {
+                if (const Building* b = universe_object_cast<const Building*>(obj))
+                    obj = objects.Object<Planet>(b->PlanetID());
+                else
+                    obj = 0;
+            } else if (property_name == System_name) {
+                if (obj)
+                    obj = objects.Object<System>(obj->SystemID());
+            } else if (property_name == Fleet_name) {
+                if (const Ship* s = universe_object_cast<const Ship*>(obj))
+                    obj = objects.Object<Fleet>(s->FleetID());
+                else
+                    obj = 0;
+            }
+            ++first;
+        }
+        return obj;
+    }
+
+    std::string ReconstructName(const std::vector<adobe::name_t>& property_name,
+                                ValueRef_2::ReferenceType ref_type)
+    {
+        std::string retval;
+        switch (ref_type) {
+        case ValueRef_2::SOURCE_REFERENCE:                    retval = "Source";          break;
+        case ValueRef_2::EFFECT_TARGET_REFERENCE: {
+            // "Value" is actually a reference to the target object, but we
+            // don't want to output "Target.Value", so if "Value" is the
+            // property name, skip prepending "Target".  Otherwise, prepend
+            // target as with other direct object references.
+
+            if (property_name[0] != Value_name)
+                retval = "Target";
+            break;
+        }
+        case ValueRef_2::CONDITION_LOCAL_CANDIDATE_REFERENCE: retval = "LocalCandidate";  break;
+        case ValueRef_2::CONDITION_ROOT_CANDIDATE_REFERENCE:  retval = "RootCandidate";   break;
+        default:                                            retval = "?????";   break;
+        }
+        for (unsigned int i = 0; i < property_name.size(); ++i) {
+            retval += '.';
+            retval += property_name[i].c_str();
+        }
+        return retval;
+    }
+
+    struct ObjectTypeVisitor : UniverseObjectVisitor
+    {
+        ObjectTypeVisitor() : m_type(INVALID_UNIVERSE_OBJECT_TYPE) {}
+
+        virtual UniverseObject* Visit(Building* obj) const
+            { m_type = OBJ_BUILDING; return obj; }
+        virtual UniverseObject* Visit(Fleet* obj) const
+            { m_type = OBJ_FLEET; return obj; }
+        virtual UniverseObject* Visit(Planet* obj) const
+            { m_type = OBJ_PLANET; return obj; }
+        virtual UniverseObject* Visit(Ship* obj) const
+            { m_type = OBJ_SHIP; return obj; }
+        virtual UniverseObject* Visit(System* obj) const
+            { m_type = OBJ_SYSTEM; return obj; }
+
+        mutable UniverseObjectType m_type;
+    };
+
+}
+
+#define CURRENT_VALUE_CASE(T)                                           \
+    if (property_name == Value_name) {                                  \
+        if (context.current_value.empty())                              \
+            throw std::runtime_error(                                   \
+                "Variable<" #T ">::Eval(): Value could not be "         \
+                "evaluated, because no current value was provided.");   \
+        try {                                                           \
+            return boost::any_cast<T>(context.current_value);           \
+        } catch (const boost::bad_any_cast&) {                          \
+            throw std::runtime_error(                                   \
+                "Variable<" #T ">::Eval(): Value could not be "         \
+                "evaluated, because the provided current value is not " \
+                "a " #T ".");                                           \
+        }                                                               \
+    }
+
+namespace ValueRef_2 { namespace detail {
+
+    template <>
+    int evaluate_variable<int>(const Variable<int>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(int)
+
+        const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+        if (!object) {
+            Logger().errorStream() << "Variable<int>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+            return 0;
+        }
+
+        if (property_name == Owner_name) {
+            return object->Owner();
+        } else if (property_name == ID_name) {
+            return object->ID();
+        } else if (property_name == CreationTurn_name) {
+            return object->CreationTurn();
+        } else if (property_name == Age_name) {
+            return object->AgeInTurns();
+        } else if (property_name == ProducedByEmpireID_name) {
+            if (const Ship* ship = universe_object_cast<const Ship*>(object))
+                return ship->ProducedByEmpireID();
+            else if (const Building* building = universe_object_cast<const Building*>(object))
+                return building->ProducedByEmpireID();
+            else
+                return ALL_EMPIRES;
+        } else if (property_name == DesignID_name) {
+            if (const Ship* ship = universe_object_cast<const Ship*>(object))
+                return ship->DesignID();
+            else
+                return ShipDesign::INVALID_DESIGN_ID;
+        } else if (property_name == FleetID_name) {
+            if (const Ship* ship = universe_object_cast<const Ship*>(object))
+                return ship->FleetID();
+            else
+                return UniverseObject::INVALID_OBJECT_ID;
+        } else if (property_name == PlanetID_name) {
+            if (const Building* building = universe_object_cast<const Building*>(object))
+                return building->PlanetID();
+            else
+                return UniverseObject::INVALID_OBJECT_ID;
+        } else if (property_name == SystemID_name) {
+            return object->SystemID();
+        } else if (property_name == FinalDestinationID_name) {
+            if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
+                return fleet->FinalDestinationID();
+            else
+                return UniverseObject::INVALID_OBJECT_ID;
+        } else if (property_name == NextSystemID_name) {
+            if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
+                return fleet->NextSystemID();
+            else
+                return UniverseObject::INVALID_OBJECT_ID;
+        } else if (property_name == PreviousSystemID_name) {
+            if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
+                return fleet->PreviousSystemID();
+            else
+                return UniverseObject::INVALID_OBJECT_ID;
+        } else if (property_name == NumShips_name) {
+            if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
+                return fleet->NumShips();
+            else
+                return 0;
+        } else if (property_name == CurrentTurn_name) {
+            return CurrentTurn();
+        } else {
+            throw std::runtime_error("Attempted to read a non-int value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type int.");
+        }
+
+        return 0;
+    }
+
+    template <>
+    double evaluate_variable<double>(const Variable<double>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(double)
+
+        const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+        if (!object) {
+            Logger().errorStream() << "Variable<double>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+            return 0.0;
+        }
+
+        if        (property_name == Population_name) {
+            return object->InitialMeterValue(METER_POPULATION);
+        } else if (property_name == TargetPopulation_name) {
+            return object->InitialMeterValue(METER_TARGET_POPULATION);
+        } else if (property_name == Health_name) {
+            return object->InitialMeterValue(METER_HEALTH);
+        } else if (property_name == TargetHealth_name) {
+            return object->InitialMeterValue(METER_TARGET_HEALTH);
+
+        } else if (property_name == Farming_name) {
+            return object->InitialMeterValue(METER_FARMING);
+        } else if (property_name == TargetFarming_name) {
+            return object->InitialMeterValue(METER_TARGET_FARMING);
+        } else if (property_name == Industry_name) {
+            return object->InitialMeterValue(METER_INDUSTRY);
+        } else if (property_name == TargetIndustry_name) {
+            return object->InitialMeterValue(METER_TARGET_INDUSTRY);
+        } else if (property_name == Research_name) {
+            return object->InitialMeterValue(METER_RESEARCH);
+        } else if (property_name == TargetResearch_name) {
+            return object->InitialMeterValue(METER_TARGET_RESEARCH);
+        } else if (property_name == Trade_name) {
+            return object->InitialMeterValue(METER_TRADE);
+        } else if (property_name == TargetTrade_name) {
+            return object->InitialMeterValue(METER_TARGET_TRADE);
+        } else if (property_name == Mining_name) {
+            return object->InitialMeterValue(METER_MINING);
+        } else if (property_name == TargetMining_name) {
+            return object->InitialMeterValue(METER_TARGET_MINING);
+        } else if (property_name == Construction_name) {
+            return object->InitialMeterValue(METER_CONSTRUCTION);
+        } else if (property_name == TargetConstruction_name) {
+            return object->InitialMeterValue(METER_TARGET_CONSTRUCTION);
+
+        } else if (property_name == MaxFuel_name) {
+            return object->InitialMeterValue(METER_MAX_FUEL);
+        } else if (property_name == Fuel_name) {
+            return object->InitialMeterValue(METER_FUEL);
+        } else if (property_name == MaxStructure_name) {
+            return object->InitialMeterValue(METER_MAX_STRUCTURE);
+        } else if (property_name == Structure_name) {
+            return object->InitialMeterValue(METER_STRUCTURE);
+        } else if (property_name == MaxShield_name) {
+            return object->InitialMeterValue(METER_MAX_SHIELD);
+        } else if (property_name == Shield_name) {
+            return object->InitialMeterValue(METER_SHIELD);
+        } else if (property_name == MaxDefense_name) {
+            return object->InitialMeterValue(METER_MAX_DEFENSE);
+        } else if (property_name == Defense_name) {
+            return object->InitialMeterValue(METER_DEFENSE);
+        } else if (property_name == MaxTroops_name) {
+            return object->InitialMeterValue(METER_MAX_TROOPS);
+        } else if (property_name == Troops_name) {
+            return object->InitialMeterValue(METER_TROOPS);
+
+        } else if (property_name == FoodConsumption_name) {
+            return object->InitialMeterValue(METER_FOOD_CONSUMPTION);
+        } else if (property_name == Supply_name) {
+            return object->InitialMeterValue(METER_SUPPLY);
+        } else if (property_name == Stealth_name) {
+            return object->InitialMeterValue(METER_STEALTH);
+        } else if (property_name == Detection_name) {
+            return object->InitialMeterValue(METER_DETECTION);
+        } else if (property_name == BattleSpeed_name) {
+            return object->InitialMeterValue(METER_BATTLE_SPEED);
+        } else if (property_name == StarlaneSpeed_name) {
+            return object->InitialMeterValue(METER_STARLANE_SPEED);
+
+        } else if (property_name == Damage_name) {
+            return object->InitialMeterValue(METER_DAMAGE);
+        } else if (property_name == ROF_name) {
+            return object->InitialMeterValue(METER_ROF);
+        } else if (property_name == Range_name) {
+            return object->InitialMeterValue(METER_RANGE);
+        } else if (property_name == Speed_name) {
+            return object->InitialMeterValue(METER_SPEED);
+        } else if (property_name == Capacity_name) {
+            return object->InitialMeterValue(METER_CAPACITY);
+        } else if (property_name == AntiShipDamage_name) {
+            return object->InitialMeterValue(METER_ANTI_SHIP_DAMAGE);
+        } else if (property_name == AntiFighterDamage_name) {
+            return object->InitialMeterValue(METER_ANTI_FIGHTER_DAMAGE);
+        } else if (property_name == LaunchRate_name) {
+            return object->InitialMeterValue(METER_LAUNCH_RATE);
+        } else if (property_name == FighterWeaponRange_name) {
+            return object->InitialMeterValue(METER_FIGHTER_WEAPON_RANGE);
+
+        } else if (property_name == TradeStockpile_name) {
+            if (Empire* empire = Empires().Lookup(object->Owner()))
+                return empire->ResourceStockpile(RE_TRADE);
+        } else if (property_name == MineralStockpile_name) {
+            if (Empire* empire = Empires().Lookup(object->Owner()))
+                return empire->ResourceStockpile(RE_MINERALS);
+        } else if (property_name == FoodStockpile_name) {
+            if (Empire* empire = Empires().Lookup(object->Owner()))
+                return empire->ResourceStockpile(RE_FOOD);
+
+        } else if (property_name == DistanceToSource_name) {
+            if (!context.source) {
+                Logger().errorStream() << "ValueRef::Variable<double>::Eval can't find distance to source because no source was passed";
+                return 0.0;
+            }
+            double delta_x = object->X() - context.source->X();
+            double delta_y = object->Y() - context.source->Y();
+            return std::sqrt(delta_x * delta_x + delta_y * delta_y);
+
+        } else {
+            throw std::runtime_error("Attempted to read a non-double value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type double.");
+        }
+
+        return 0.0;
+    }
+
+    template <>
+    std::string evaluate_variable<std::string>(const Variable<std::string>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(std::string)
+
+        const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+        if (!object) {
+            Logger().errorStream() << "Variable<std::string>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+            return "";
+        }
+
+        if (property_name == Name_name) {
+            return object->Name();
+        } else if (property_name == Species_name) {
+            if (const Planet* planet = universe_object_cast<const Planet*>(object))
+                return planet->SpeciesName();
+            else if (const Ship* ship = universe_object_cast<const Ship*>(object))
+                return ship->SpeciesName();
+        } else if (property_name == BuildingType_name) {
+            if (const Building* building = universe_object_cast<const Building*>(object))
+                return building->BuildingTypeName();
+        } else if (property_name == Focus_name) {
+            if (const Planet* planet = universe_object_cast<const Planet*>(object))
+                return planet->Focus();
+        } else {
+            throw std::runtime_error("Attempted to read a non-string value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type std::string.");
+        }
+
+        return "";
+    }
+
+    template <>
+    PlanetSize evaluate_variable<PlanetSize>(const Variable<PlanetSize>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(PlanetSize);
+
+        if (property_name == PlanetSize_name) {
+            const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+            if (!object) {
+                Logger().errorStream() << "Variable<PlanetSize>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+                return INVALID_PLANET_SIZE;
+            }
+            if (const Planet* p = universe_object_cast<const Planet*>(object))
+                return p->Size();
+        } else {
+            throw std::runtime_error("Attempted to read a non-PlanetSize value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type PlanetSize.");
+        }
+
+        return INVALID_PLANET_SIZE;
+    }
+
+    template <>
+    PlanetType evaluate_variable<PlanetType>(const Variable<PlanetType>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(PlanetType)
+
+        const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+        if (!object) {
+            Logger().errorStream() << "Variable<PlanetType>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+            return INVALID_PLANET_TYPE;
+        }
+
+        if (property_name == PlanetType_name) {
+            if (const Planet* p = universe_object_cast<const Planet*>(object))
+                return p->Type();
+        } else if (property_name == NextBetterPlanetType_name) {
+            if (const Planet* p = universe_object_cast<const Planet*>(object))
+                return p->NextBetterPlanetTypeForSpecies();
+        } else {
+            throw std::runtime_error("Attempted to read a non-PlanetType value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type PlanetType.");
+        }
+
+        return INVALID_PLANET_TYPE;
+    }
+
+    template <>
+    PlanetEnvironment evaluate_variable<PlanetEnvironment>(const Variable<PlanetEnvironment>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(PlanetEnvironment);
+
+        if (property_name == PlanetEnvironment_name) {
+            const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+            if (!object) {
+                Logger().errorStream() << "Variable<PlanetEnvironment>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+                return INVALID_PLANET_ENVIRONMENT;
+            }
+            if (const Planet* p = universe_object_cast<const Planet*>(object))
+                return p->EnvironmentForSpecies();
+        } else {
+            throw std::runtime_error("Attempted to read a non-PlanetEnvironment value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type PlanetEnvironment.");
+        }
+
+        return INVALID_PLANET_ENVIRONMENT;
+    }
+
+    template <>
+    UniverseObjectType evaluate_variable<UniverseObjectType>(const Variable<UniverseObjectType>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(UniverseObjectType)
+
+        if (property_name == ObjectType_name) {
+            const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+            if (!object) {
+                Logger().errorStream() << "Variable<UniverseObjectType>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+                return INVALID_UNIVERSE_OBJECT_TYPE;
+            }
+            ObjectTypeVisitor v;
+            if (object->Accept(v)) {
+                return v.m_type;
+            } else if (dynamic_cast<const PopCenter*>(object)) {
+                return OBJ_POP_CENTER;
+            } else if (dynamic_cast<const ResourceCenter*>(object)) {
+                return OBJ_PROD_CENTER;
+            }
+        } else {
+            throw std::runtime_error("Attempted to read a non-ObjectType value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type ObjectType.");
+        }
+        return INVALID_UNIVERSE_OBJECT_TYPE;
+    }
+
+    template <>
+    StarType evaluate_variable<StarType>(const Variable<StarType>& e, const ScriptingContext& context)
+    {
+        adobe::name_t property_name = e.m_property_name.back();
+
+        CURRENT_VALUE_CASE(StarType)
+
+        if (property_name == StarType_name) {
+            const UniverseObject* object = FollowReference(e.m_property_name.begin(), e.m_property_name.end(), e.m_ref_type, context);
+            if (!object) {
+                Logger().errorStream() << "Variable<StarType>::Eval unable to follow reference: " << ReconstructName(e.m_property_name, e.m_ref_type);
+                return INVALID_STAR_TYPE;
+            }
+            if (const System* s = universe_object_cast<const System*>(object))
+                return s->GetStarType();
+        } else {
+            throw std::runtime_error("Attempted to read a non-StarType value \"" + ReconstructName(e.m_property_name, e.m_ref_type) + "\" using a ValueRef of type StarType.");
+        }
+        return INVALID_STAR_TYPE;
+    }
+
+} }
+
+#undef CURRENT_VALUE_CASE
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 4423)
+++ CMakeLists.txt	(working copy)
@@ -333,6 +333,13 @@
 add_subdirectory(client/AI)
 add_subdirectory(client/human)
 
+option(BUILD_PARSER_TESTS "Controls generation of parser unit tests." OFF)
+
+if (BUILD_PARSER_TESTS)
+    enable_testing()
+    add_subdirectory(parse)
+endif ()
+
 ########################################
 # Win32 SDK-only steps                 #
 ########################################
