Index: default/techs.txt
===================================================================
--- default/techs.txt	(revision 4463)
+++ default/techs.txt	(working copy)
@@ -36,7 +36,6 @@
     category = "DEFENSE_CATEGORY"
     researchcost = 10
     researchturns = 1
-    prerequisites = []
     unlock = Item type = ShipPart name = "SH_DEFENSE_GRID"
     effectsgroups =
         EffectsGroup
@@ -54,7 +53,6 @@
     researchcost = 20
     researchturns = 2
     prerequisites = "DEF_ROOT_DEFENSE"
-    unlock = []
     effectsgroups =
         EffectsGroup
             scope = OwnedBy TheEmpire Source.Owner
@@ -71,7 +69,6 @@
     researchcost = 50
     researchturns = 5
     prerequisites = "DEF_GARRISON_1"
-    unlock = []
     effectsgroups =
         EffectsGroup
             scope = OwnedBy TheEmpire Source.Owner
@@ -88,7 +85,6 @@
     researchcost = 150
     researchturns = 8
     prerequisites = "DEF_GARRISON_2"
-    unlock = []
     effectsgroups =
         EffectsGroup
             scope = OwnedBy TheEmpire Source.Owner
@@ -105,7 +101,6 @@
     researchcost = 400
     researchturns = 15
     prerequisites = "DEF_GARRISON_3"
-    unlock = []
     effectsgroups =
         EffectsGroup
             scope = OwnedBy TheEmpire Source.Owner
@@ -120,7 +115,6 @@
     category = "SHIPS_CATEGORY"
     researchcost = 10
     researchturns = 1
-    prerequisites = []
     unlock = [
         Item type = ShipPart name = "SR_WEAPON_1"
         Item type = ShipPart name = "GT_TROOP_POD"
@@ -3725,4 +3719,4 @@
     researchturns = 2
     prerequisites = "SHP_MAX_DISRUPT"
     unlock = Item type = ShipPart name = "LR_SPECTRAL_MISSILE"
-*/
\ No newline at end of file
+*/
Index: default/buildings.txt
===================================================================
--- default/buildings.txt	(revision 4463)
+++ default/buildings.txt	(working copy)
@@ -781,29 +781,6 @@
     graphic = "icons/building/blackhole.png"
 
 BuildingType
-    name = "BLD_SOL_ACCEL"
-    description = "BLD_SOL_ACCEL_DESC"
-    buildcost = 800
-    buildtime = 3
-    location = OwnedBy TheEmpire Source.Owner
-    effectsgroups = [
-        EffectsGroup
-            scope = Contains Source
-            activation = And [
-                Not Star type = BlackHole
-                Not Star type = Red
-                Not Star type = Neutron
-            ]
-            effects = SetStarType Target.System.StarType + 1
-
-        EffectsGroup
-            scope = Source
-            activation = Source
-            effects = Destroy
-    ]
-    graphic = "icons/building/miniature_sun.png"
-
-BuildingType
     name = "BLD_SOL_ORB_GEN"
     description = "BLD_SOL_ORB_GEN_DESC"
     buildcost = 750
@@ -951,9 +928,7 @@
     description = "BLD_CONC_CAMP_DESC"
     buildcost = 50
     buildtime = 1
-    location = And [
-        OwnedBy TheEmpire Source.Owner
-    ]
+    location = OwnedBy TheEmpire Source.Owner
     effectsgroups = [
         EffectsGroup
             scope = Contains Source
@@ -1088,29 +1063,6 @@
     graphic = ""
 
 BuildingType
-    name = "BLD_SOL_REJUV"
-    description = "BLD_SOL_REJUV_DESC"
-    buildcost = 800
-    buildtime = 3
-    location = OwnedBy TheEmpire Source.Owner
-    effectsgroups = [
-        EffectsGroup
-            scope = Contains Source
-            activation = And [
-                Not Star type = BlackHole
-                Not Star type = Blue
-                Not Star type = Neutron
-            ]
-            effects = SetStarType Target.System.StarType - 1
-
-        EffectsGroup
-            scope = Source
-            activation = Source
-            effects = Destroy
-    ]
-    graphic = ""
-
-BuildingType
     name = "BLD_TRANSFORMER"
     description = "BLD_TRANSFORMER_DESC"
     buildcost = 1000
Index: universe/Universe.cpp
===================================================================
--- universe/Universe.cpp	(revision 4463)
+++ universe/Universe.cpp	(working copy)
@@ -6,6 +6,7 @@
 #include "../util/OptionsDB.h"
 #include "../util/Directories.h"
 #include "../util/Random.h"
+#include "../parse/Parse.h"
 #include "../Empire/Empire.h"
 #include "../Empire/EmpireManager.h"
 #include "Building.h"
@@ -19,12 +20,11 @@
 #include "Predicates.h"
 #include "Special.h"
 #include "Species.h"
-#include "Parser.h"
-#include "ParserUtil.h"
 #include "Condition.h"
 #include "ValueRef.h"
 
-
+#include <boost/algorithm/string/classification.hpp>
+#include <boost/algorithm/string/split.hpp>
 #include <boost/filesystem/fstream.hpp>
 #include <boost/graph/adjacency_list.hpp>
 #include <boost/graph/breadth_first_search.hpp>
@@ -2939,15 +2939,6 @@
 // FleetPlanManager //
 //////////////////////
 namespace {
-    struct store_fleet_plan_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::vector<FleetPlan*>& fleet_plans, const T& fleet_plan) const
-        { fleet_plans.push_back(fleet_plan); }
-    };
-    const phoenix::function<store_fleet_plan_impl> store_fleet_plan_;
-
     class FleetPlanManager {
     public:
         typedef std::vector<FleetPlan*>::const_iterator iterator;
@@ -2979,28 +2970,8 @@
 
         Logger().debugStream() << "Initializing FleetPlanManager";
 
-        std::string file_name = "starting_fleets.txt";
-        std::string input;
+        parse::fleet_plans(GetResourceDir() / "starting_fleets.txt", m_plans);
 
-        boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-        if (ifs) {
-            std::getline(ifs, input, '\0');
-            ifs.close();
-        } else {
-            Logger().errorStream() << "Unable to open data file " << file_name;
-            return;
-        }
-
-        using namespace boost::spirit::classic;
-        using namespace phoenix;
-        parse_info<const char*> result =
-            parse(input.c_str(),
-                  as_lower_d[*fleet_plan_p[store_fleet_plan_(var(m_plans), arg1)]]
-                  >> end_p,
-                  skip_p);
-        if (!result.full)
-            ReportError(input.c_str(), result);
-
 #ifdef OUTPUT_PLANS_LIST
         Logger().debugStream() << "Starting Fleet Plans:";
         for (iterator it = begin(); it != end(); ++it)
@@ -3024,15 +2995,6 @@
 // MonsterFleetPlanManager //
 /////////////////////////////
 namespace {
-    struct store_monster_fleet_plan_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::vector<MonsterFleetPlan*>& fleet_plans, const T& fleet_plan) const
-        { fleet_plans.push_back(fleet_plan); }
-    };
-    const phoenix::function<store_monster_fleet_plan_impl> store_monster_fleet_plan_;
-
     class MonsterFleetPlanManager {
     public:
         typedef std::vector<MonsterFleetPlan*>::const_iterator iterator;
@@ -3066,28 +3028,8 @@
 
         Logger().debugStream() << "Initializing MonsterFleetPlanManager";
 
-        std::string file_name = "space_monster_spawn_fleets.txt";
-        std::string input;
+        parse::monster_fleet_plans(GetResourceDir() / "space_monster_spawn_fleets.txt", m_plans);
 
-        boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-        if (ifs) {
-            std::getline(ifs, input, '\0');
-            ifs.close();
-        } else {
-            Logger().errorStream() << "Unable to open data file " << file_name;
-            return;
-        }
-
-        using namespace boost::spirit::classic;
-        using namespace phoenix;
-        parse_info<const char*> result =
-            parse(input.c_str(),
-                  as_lower_d[*monster_fleet_plan_p[store_monster_fleet_plan_(var(m_plans), arg1)]]
-                  >> end_p,
-                  skip_p);
-        if (!result.full)
-            ReportError(input.c_str(), result);
-
 //#ifdef OUTPUT_PLANS_LIST
         Logger().debugStream() << "Starting Monster Fleet Plans:";
         for (iterator it = begin(); it != end(); ++it)
@@ -3111,15 +3053,6 @@
 // ItemSpecManager         //
 /////////////////////////////
 namespace {
-    struct store_item_spec_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::vector<ItemSpec>& item_specs, const T& item_spec) const
-        { item_specs.push_back(item_spec); }
-    };
-    const phoenix::function<store_item_spec_impl> store_item_spec_;
-
     class ItemSpecManager {
     public:
         typedef std::vector<ItemSpec>::const_iterator iterator;
@@ -3154,28 +3087,8 @@
 
         Logger().debugStream() << "Initializing ItemSpecManager";
 
-        std::string file_name = "preunlocked_items.txt";
-        std::string input;
+        parse::items(GetResourceDir() / "preunlocked_items.txt", m_items);
 
-        boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-        if (ifs) {
-            std::getline(ifs, input, '\0');
-            ifs.close();
-        } else {
-            Logger().errorStream() << "Unable to open data file " << file_name;
-            return;
-        }
-
-        using namespace boost::spirit::classic;
-        using namespace phoenix;
-        parse_info<const char*> result =
-            parse(input.c_str(),
-                  as_lower_d[*item_spec_p[store_item_spec_(var(m_items), arg1)]]
-                  >> end_p,
-                  skip_p);
-        if (!result.full)
-            ReportError(input.c_str(), result);
-
 #ifdef OUTPUT_ITEM_SPECS_LIST
         Logger().debugStream() << "Starting Unlocked Item Specs:";
         for (iterator it = begin(); it != end(); ++it) {
@@ -4509,15 +4422,6 @@
 }
 
 namespace {
-    struct store_name_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::vector<std::string>& names, const T& name) const
-        { names.push_back(name); }
-    };
-    const phoenix::function<store_name_impl> store_name_;
-
     /** Reads list of strings from file, surrounded by enclosing quotes. */
     void LoadNames(std::vector<std::string>& names, const std::string& file_name) {
         names.clear();
@@ -4529,15 +4433,14 @@
         } else {
             Logger().errorStream() << "Unable to open data file " << file_name;
         }
-        using namespace boost::spirit::classic;
-        using namespace phoenix;
-        parse_info<const char*> result =
-            parse(input.c_str(),
-                  *name_p[store_name_(var(names), arg1)]
-                  >> end_p,
-                  skip_p);
-        if (!result.full)
-            ReportError(input.c_str(), result);
+        using namespace boost::algorithm;
+        split(names, input, is_any_of("\"\n"), token_compress_on);
+        for (std::size_t i = 0; i < names.size(); ) {
+            if (names[i].empty())
+                names.erase(names.begin() + i);
+            else
+                ++i;
+        }
     }
 };
 
Index: universe/Names.h
===================================================================
--- universe/Names.h	(revision 0)
+++ universe/Names.h	(revision 0)
@@ -0,0 +1,354 @@
+// -*- C++ -*-
+#ifndef _Names_h_
+#define _Names_h_
+
+#include <GG/adobe/name.hpp>
+
+#include <boost/preprocessor/cat.hpp>
+#include <boost/preprocessor/seq/for_each.hpp>
+
+
+#define NAMES_SEQ_1                             \
+    (Activation)                                \
+    (AddedBefore)                               \
+    (AddedSince)                                \
+    (AddSpecial)                                \
+    (AddStarlanes)                              \
+    (Adequate)                                  \
+    (Affiliation)                               \
+    (Age)                                       \
+    (Alignment)                                 \
+    (AlignmentEffects)                          \
+    (All)                                       \
+    (AllocatedFood)                             \
+    (AllyOf)                                    \
+    (And)                                       \
+    (AntiFighterDamage)                         \
+    (AntiShipDamage)                            \
+    (AnyEmpire)                                 \
+    (Armed)                                     \
+    (Armour)                                    \
+    (Application)                               \
+    (Asteroids)                                 \
+    (Barren)                                    \
+    (BattleSpeed)                               \
+    (BlackHole)                                 \
+    (Blue)                                      \
+    (Bomber)                                    \
+    (BuildCost)                                 \
+    (Building)                                  \
+    (BuildingType)                              \
+    (BuildTime)                                 \
+    (CanColonize)                               \
+    (CanProduceShips)                           \
+    (Capacity)                                  \
+    (Capital)                                   \
+    (Capture)                                   \
+    (CaptureResult)                             \
+    (Category)                                  \
+    (Class)                                     \
+    (Colony)                                    \
+    (Colour)                                    \
+    (Condition)                                 \
+    (Construction)                              \
+    (ContainedBy)                               \
+    (Contains)                                  \
+    (Count)                                     \
+    (CreateBuilding)                            \
+    (CreatedOnTurn)                             \
+    (CreatePlanet)                              \
+    (CreateShip)                                \
+    (CreationTurn)                              \
+    (CurrentTurn)                               \
+    (Damage)                                    \
+    (Data)                                      \
+    (Defense)                                   \
+    (Description)                               \
+    (Desert)                                    \
+    (Design)                                    \
+    (DesignHasHull)                             \
+    (DesignHasPart)                             \
+    (DesignHasPartClass)                        \
+    (DesignID)                                  \
+    (DesignName)                                \
+    (Destination)                               \
+    (Destroy)                                   \
+    (Detection)                                 \
+    (Distance)                                  \
+    (DistanceToSource)                          \
+    (Effects)                                   \
+    (EffectsGroup)                              \
+    (EffectsGroups)                             \
+    (Empire)                                    \
+    (Endpoint)                                  \
+    (EnemyOf)                                   \
+    (Environment)                               \
+    (Environments)                              \
+    (ExploredByEmpire)                          \
+    (External)                                  \
+    (Farming)                                   \
+    (Fighters)                                  \
+    (FighterType)                               \
+    (FighterWeaponRange)                        \
+    (FinalDestinationID)                        \
+    (Fleet)                                     \
+    (FleetID)                                   \
+    (FleetSupplyableByEmpire)                   \
+    (Foci)                                      \
+    (Focus)                                     \
+    (FocusType)                                 \
+    (FoodAllocationForMaxGrowth)                \
+    (FoodConsumption)                           \
+    (FoodStockpile)                             \
+    (Fuel)                                      \
+    (GasGiant)                                  \
+    (GenerateSitrepMessage)                     \
+    (GiveTechToOwner)                           \
+    (Good)                                      \
+    (Graphic)                                   \
+    (HasSpecial)                                \
+    (HasSpecialSinceTurn)                       \
+    (Health)                                    \
+    (High)                                      \
+    (Homeworld)                                 \
+    (Hostile)                                   \
+    (Huge)                                      \
+    (Hull)                                      \
+    (ID)                                        \
+    (Industry)                                  \
+    (Inferno)                                   \
+    (InSystem)                                  \
+    (Interceptor)                               \
+    (Internal)                                  \
+    (Item)                                      \
+    (Jumps)                                     \
+    (Label)                                     \
+    (Large)                                     \
+    (LastTurnBattleHere)                        \
+    (LaunchRate)                                \
+    (LocalCandidate)                            \
+    (Location)                                  \
+    (LockTechItemsForOwner)                     \
+    (Low)                                       \
+    (Max)                                       \
+    (MaxDefense)                                \
+    (MaxFuel)                                   \
+    (MaximumNumberOf)                           \
+    (MaxShield)                                 \
+    (MaxStructure)                              \
+    (MaxTroops)                                 \
+    (Mean)                                      \
+    (Medium)                                    \
+    (Message)                                   \
+    (Meter)                                     \
+    (Min)                                       \
+    (MineralStockpile)                          \
+    (MinimumNumberOf)                           \
+    (Mining)                                    \
+    (Missiles)                                  \
+    (Mode)                                      \
+    (Model)                                     \
+    (ModeNumberOf)                              \
+    (Monster)                                   \
+    (MonsterFleet)                              \
+    (MountableSlotTypes)                        \
+    (MoveTo)                                    \
+    (Name)                                      \
+    (Neutron)                                   \
+    (NextBetterPlanetType)                      \
+    (NextSystemID)                              \
+    (NonObject)                                 \
+    (NoStar)                                    \
+    (Not)                                       \
+    (Number)                                    \
+    (NumberOf)                                  \
+    (NumShips)                                  \
+    (Object)                                    \
+    (ObjectType)                                \
+    (Ocean)                                     \
+    (Or)                                        \
+    (Orange)                                    \
+    (OwnedBy)                                   \
+    (Owner)                                     \
+    (OwnerFoodStockpile)                        \
+    (OwnerHasTech)                              \
+    (OwnerMineralStockpile)                     \
+    (OwnerTradeStockpile)                       \
+    (Parameters)                                \
+    (Part)                                      \
+    (PartClass)
+
+#define NAMES_SEQ_2                             \
+    (PartName)                                  \
+    (Parts)                                     \
+    (Planet)                                    \
+    (Planetbound)                               \
+    (PlanetEnvironment)                         \
+    (PlanetID)                                  \
+    (PlanetSize)                                \
+    (PlanetType)                                \
+    (Playable)                                  \
+    (PointDefense)                              \
+    (Poor)                                      \
+    (Population)                                \
+    (PopulationCenter)                          \
+    (Position)                                  \
+    (Prerequisites)                             \
+    (PreviousSystemID)                          \
+    (Probability)                               \
+    (ProducedByEmpire)                          \
+    (ProducedByEmpireID)                        \
+    (Producible)                                \
+    (Product)                                   \
+    (ProductionCenter)                          \
+    (Property)                                  \
+    (Radiated)                                  \
+    (Random)                                    \
+    (Range)                                     \
+    (Reason)                                    \
+    (Red)                                       \
+    (Refinement)                                \
+    (RemoveSpecial)                             \
+    (RemoveStarlanes)                           \
+    (Research)                                  \
+    (Researchable)                              \
+    (ResearchCost)                              \
+    (ResearchTurns)                             \
+    (ResourceSupplyConnected)                   \
+    (ResupplyableBy)                            \
+    (Retain)                                    \
+    (RevokeTechFromOwner)                       \
+    (RMS)                                       \
+    (ROF)                                       \
+    (RootCandidate)                             \
+    (Scope)                                     \
+    (SetAntiFighterDamage)                      \
+    (SetAntiShipDamage)                         \
+    (SetBattleSpeed)                            \
+    (SetCapacity)                               \
+    (SetConstruction)                           \
+    (SetDamage)                                 \
+    (SetDefense)                                \
+    (SetDestination)                            \
+    (SetDetection)                              \
+    (SetEmpireCapital)                          \
+    (SetEmpireFoodStockpile)                    \
+    (SetEmpireMeter)                            \
+    (SetEmpireMineralStockpile)                 \
+    (SetEmpireTradeStockpile)                   \
+    (SetFarming)                                \
+    (SetFighterWeaponRange)                     \
+    (SetFoodConsumption)                        \
+    (SetFuel)                                   \
+    (SetHealth)                                 \
+    (SetIndustry)                               \
+    (SetLaunchRate)                             \
+    (SetMaxDefense)                             \
+    (SetMaxFuel)                                \
+    (SetMaxShield)                              \
+    (SetMaxStructure)                           \
+    (SetMaxTroops)                              \
+    (SetMining)                                 \
+    (SetOwner)                                  \
+    (SetPlanetSize)                             \
+    (SetPlanetType)                             \
+    (SetPopulation)                             \
+    (SetRange)                                  \
+    (SetResearch)                               \
+    (SetROF)                                    \
+    (SetShield)                                 \
+    (SetSpecies)                                \
+    (SetSpeed)                                  \
+    (SetStarlaneSpeed)                          \
+    (SetStarType)                               \
+    (SetStealth)                                \
+    (SetStructure)                              \
+    (SetSupply)                                 \
+    (SetTargetConstruction)                     \
+    (SetTargetFarming)                          \
+    (SetTargetHealth)                           \
+    (SetTargetIndustry)                         \
+    (SetTargetMining)                           \
+    (SetTargetPopulation)                       \
+    (SetTargetResearch)                         \
+    (SetTargetTrade)                            \
+    (SetTrade)                                  \
+    (SetTroops)                                 \
+    (Shield)                                    \
+    (ShipDesign)                                \
+    (Ship)                                      \
+    (ShipHull)                                  \
+    (ShipPart)                                  \
+    (Ships)                                     \
+    (Short_Description)                         \
+    (ShortRange)                                \
+    (Size)                                      \
+    (Slot)                                      \
+    (Slots)                                     \
+    (SlotType)                                  \
+    (Small)                                     \
+    (SortBy)                                    \
+    (SortKey)                                   \
+    (Source)                                    \
+    (Spacebound)                                \
+    (SpawnLimit)                                \
+    (SpawnRate)                                 \
+    (Special)                                   \
+    (Species)                                   \
+    (Speed)                                     \
+    (Spread)                                    \
+    (StackingGroup)                             \
+    (Star)                                      \
+    (StarlaneSpeed)                             \
+    (StarType)                                  \
+    (Stationary)                                \
+    (StDev)                                     \
+    (Stealth)                                   \
+    (Structure)                                 \
+    (Sum)                                       \
+    (Supply)                                    \
+    (Swamp)                                     \
+    (System)                                    \
+    (SystemID)                                  \
+    (Tag)                                       \
+    (Target)                                    \
+    (TargetConstruction)                        \
+    (TargetFarming)                             \
+    (TargetHealth)                              \
+    (TargetIndustry)                            \
+    (TargetMining)                              \
+    (TargetPopulation)                          \
+    (TargetResearch)                            \
+    (TargetTrade)                               \
+    (Tech)                                      \
+    (TechType)                                  \
+    (Terran)                                    \
+    (TheEmpire)                                 \
+    (Theory)                                    \
+    (Tiny)                                      \
+    (Toxic)                                     \
+    (Trade)                                     \
+    (TradeStockpile)                            \
+    (Troops)                                    \
+    (Tundra)                                    \
+    (Turn)                                      \
+    (Type)                                      \
+    (Uninhabitable)                             \
+    (Unlock)                                    \
+    (UnlockTechItemsForOwner)                   \
+    (Unproducible)                              \
+    (Unresearchable)                            \
+    (Value)                                     \
+    (Victory)                                   \
+    (VisibleToEmpire)                           \
+    (White)                                     \
+    (WithinDistance)                            \
+    (WithinStarlaneJumps)                       \
+    (Yellow)
+
+#define DECLARE_NAME(r, _, elem) extern adobe::aggregate_name_t BOOST_PP_CAT(elem, _name);
+BOOST_PP_SEQ_FOR_EACH(DECLARE_NAME, _, NAMES_SEQ_1)
+BOOST_PP_SEQ_FOR_EACH(DECLARE_NAME, _, NAMES_SEQ_2)
+#undef DECLARE_NAME
+
+#endif
Index: universe/ValueRef.cpp
===================================================================
--- universe/ValueRef.cpp	(revision 4463)
+++ universe/ValueRef.cpp	(working copy)
@@ -11,9 +11,11 @@
 #include "../Empire/Empire.h"
 #include "../util/MultiplayerCommon.h"
 
-#include <boost/spirit/include/classic.hpp>
-#include <boost/algorithm/string.hpp>
+#include <GG/adobe/closed_hash.hpp>
 
+#include <boost/algorithm/string/classification.hpp>
+#include <boost/algorithm/string/split.hpp>
+
 int g_indent = 0;
 
 
@@ -41,7 +43,6 @@
     condition_local_candidate(0)
 {}
 
-
 ScriptingContext::ScriptingContext(const UniverseObject* source_, UniverseObject* target_,
                                    const boost::any& current_value_) :
     source(source_),
@@ -85,17 +86,22 @@
 namespace detail {
     std::vector<std::string> TokenizeDottedReference(const std::string& str)
     {
-        using namespace boost::spirit::classic;
         std::vector<std::string> retval;
-        rule<> tokenizer = *((+(anychar_p - '.'))[append(retval)] >> !ch_p('.'));
-        parse(str.c_str(), tokenizer);
+        boost::algorithm::split(retval, str, boost::algorithm::is_any_of("."));
         return retval;
     }
+
+    std::vector<adobe::name_t> PrependNonObject(const std::vector<adobe::name_t>& property_name)
+    {
+        std::vector<adobe::name_t> retval(1, NonObject_name);
+        retval.insert(retval.end(), property_name.begin(), property_name.end());
+        return retval;
+    }
 }
 
 namespace {
-    const UniverseObject* FollowReference(std::vector<std::string>::const_iterator first,
-                                          std::vector<std::string>::const_iterator last,
+    const UniverseObject* FollowReference(std::vector<adobe::name_t>::const_iterator first,
+                                          std::vector<adobe::name_t>::const_iterator last,
                                           ValueRef::ReferenceType ref_type,
                                           ScriptingContext context)
     {
@@ -116,16 +122,16 @@
 
         const ObjectMap& objects = GetMainObjectMap();
         while (first != last) {
-            const std::string& property_name = *first;
-            if (boost::iequals(property_name, "Planet")) {
+            adobe::name_t property_name = *first;
+            if (property_name == Planet_name) {
                 if (const Building* b = universe_object_cast<const Building*>(obj))
                     obj = objects.Object<Planet>(b->PlanetID());
                 else
                     obj = 0;
-            } else if (boost::iequals(property_name, "System")) {
+            } else if (property_name == System_name) {
                 if (obj)
                     obj = objects.Object<System>(obj->SystemID());
-            } else if (boost::iequals(property_name, "Fleet")) {
+            } else if (property_name == Fleet_name) {
                 if (const Ship* s = universe_object_cast<const Ship*>(obj))
                     obj = objects.Object<Fleet>(s->FleetID());
                 else
@@ -135,9 +141,84 @@
         }
         return obj;
     }
+
+    struct ObjectTypeVisitor : UniverseObjectVisitor
+    {
+        ObjectTypeVisitor() : m_type(INVALID_UNIVERSE_OBJECT_TYPE) {}
+
+        virtual UniverseObject* Visit(Building* obj) const
+            { m_type = OBJ_BUILDING; return obj; }
+        virtual UniverseObject* Visit(Fleet* obj) const
+            { m_type = OBJ_FLEET; return obj; }
+        virtual UniverseObject* Visit(Planet* obj) const
+            { m_type = OBJ_PLANET; return obj; }
+        virtual UniverseObject* Visit(Ship* obj) const
+            { m_type = OBJ_SHIP; return obj; }
+        virtual UniverseObject* Visit(System* obj) const
+            { m_type = OBJ_SYSTEM; return obj; }
+
+        mutable UniverseObjectType m_type;
+    };
+
+    MeterType NameToMeter(adobe::name_t name)
+    {
+        typedef adobe::closed_hash_map<adobe::name_t, MeterType> NameToMeterMap;
+        static NameToMeterMap map;
+        static bool once = true;
+        if (once) {
+            map[Population_name] = METER_POPULATION;
+            map[TargetPopulation_name] = METER_TARGET_POPULATION;
+            map[Health_name] = METER_HEALTH;
+            map[TargetHealth_name] = METER_TARGET_HEALTH;
+            map[Farming_name] = METER_FARMING;
+            map[TargetFarming_name] = METER_TARGET_FARMING;
+            map[Industry_name] = METER_INDUSTRY;
+            map[TargetIndustry_name] = METER_TARGET_INDUSTRY;
+            map[Research_name] = METER_RESEARCH;
+            map[TargetResearch_name] = METER_TARGET_RESEARCH;
+            map[Trade_name] = METER_TRADE;
+            map[TargetTrade_name] = METER_TARGET_TRADE;
+            map[Mining_name] = METER_MINING;
+            map[TargetMining_name] = METER_TARGET_MINING;
+            map[Construction_name] = METER_CONSTRUCTION;
+            map[TargetConstruction_name] = METER_TARGET_CONSTRUCTION;
+            map[MaxFuel_name] = METER_MAX_FUEL;
+            map[Fuel_name] = METER_FUEL;
+            map[MaxStructure_name] = METER_MAX_STRUCTURE;
+            map[Structure_name] = METER_STRUCTURE;
+            map[MaxShield_name] = METER_MAX_SHIELD;
+            map[Shield_name] = METER_SHIELD;
+            map[MaxDefense_name] = METER_MAX_DEFENSE;
+            map[Defense_name] = METER_DEFENSE;
+            map[MaxTroops_name] = METER_MAX_TROOPS;
+            map[Troops_name] = METER_TROOPS;
+            map[FoodConsumption_name] = METER_FOOD_CONSUMPTION;
+            map[Supply_name] = METER_SUPPLY;
+            map[Stealth_name] = METER_STEALTH;
+            map[Detection_name] = METER_DETECTION;
+            map[BattleSpeed_name] = METER_BATTLE_SPEED;
+            map[StarlaneSpeed_name] = METER_STARLANE_SPEED;
+            map[Damage_name] = METER_DAMAGE;
+            map[ROF_name] = METER_ROF;
+            map[Range_name] = METER_RANGE;
+            map[Speed_name] = METER_SPEED;
+            map[Capacity_name] = METER_CAPACITY;
+            map[AntiShipDamage_name] = METER_ANTI_SHIP_DAMAGE;
+            map[AntiFighterDamage_name] = METER_ANTI_FIGHTER_DAMAGE;
+            map[LaunchRate_name] = METER_LAUNCH_RATE;
+            map[FighterWeaponRange_name] = METER_FIGHTER_WEAPON_RANGE;
+            once = false;
+        }
+        MeterType retval = INVALID_METER_TYPE;
+        NameToMeterMap::const_iterator it = map.find(name);
+        if (it != map.end())
+            retval = it->second;
+        return retval;
+    }
+
 }
 
-std::string ValueRef::ReconstructName(const std::vector<std::string>& property_name,
+std::string ValueRef::ReconstructName(const std::vector<adobe::name_t>& property_name,
                                       ValueRef::ReferenceType ref_type)
 {
     std::string retval;
@@ -148,7 +229,7 @@
         // don't want to output "Target.Value", so if "Value" is the
         // property name, skip prepending "Target".  Otherwise, prepend
         // target as with other direct object references.
-        if (!boost::iequals(property_name[0], "Value"))
+        if (property_name[0] != Value_name)
             retval = "Target";
         break;
     }
@@ -158,10 +239,10 @@
     default:                                            retval = "?????";           break;
     }
 
-    for (unsigned int i = 0; i < property_name.size(); ++i) {
+    for (std::size_t i = 0; i < property_name.size(); ++i) {
         if (!retval.empty())
             retval += '.';
-        retval += property_name[i];
+        retval += property_name[i].c_str();
     }
     return retval;
 }
@@ -282,14 +363,14 @@
 ///////////////////////////////////////////////////////////
 namespace ValueRef {
 
-#define IF_CURRENT_VALUE(T)                                           \
-    if (boost::iequals(property_name, "Value")) {                          \
-        if (context.current_value.empty())                             \
+#define IF_CURRENT_VALUE(T)                                                \
+    if (property_name == Value_name) {                                     \
+        if (context.current_value.empty())                                 \
             throw std::runtime_error(                                      \
                 "Variable<" #T ">::Eval(): Value could not be evaluated, " \
                 "because no current value was provided.");                 \
         try {                                                              \
-            return boost::any_cast<T>(context.current_value);          \
+            return boost::any_cast<T>(context.current_value);              \
         } catch (const boost::bad_any_cast&) {                             \
             throw std::runtime_error(                                      \
                 "Variable<" #T ">::Eval(): Value could not be evaluated, " \
@@ -300,11 +381,11 @@
     template <>
     PlanetSize Variable<PlanetSize>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(PlanetSize)
 
-        if (boost::iequals(property_name, "PlanetSize")) {
+        if (property_name == PlanetSize_name) {
             const UniverseObject* object = FollowReference(m_property_name.begin(), m_property_name.end(), m_ref_type, context);
             if (!object) {
                 Logger().errorStream() << "Variable<PlanetSize>::Eval unable to follow reference: " << ReconstructName(m_property_name, m_ref_type);
@@ -321,7 +402,7 @@
     template <>
     PlanetType Variable<PlanetType>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(PlanetType)
 
@@ -331,10 +412,10 @@
             return INVALID_PLANET_TYPE;
         }
 
-        if (boost::iequals(property_name, "PlanetType")) {
+        if (property_name == PlanetType_name) {
             if (const Planet* p = universe_object_cast<const Planet*>(object))
                 return p->Type();
-        } else if (boost::iequals(property_name, "NextBetterPlanetType")) {
+        } else if (property_name == NextBetterPlanetType_name) {
             if (const Planet* p = universe_object_cast<const Planet*>(object))
                 return p->NextBetterPlanetTypeForSpecies();
         } else {
@@ -346,11 +427,11 @@
     template <>
     PlanetEnvironment Variable<PlanetEnvironment>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(PlanetEnvironment)
 
-        if (boost::iequals(property_name, "PlanetEnvironment")) {
+        if (property_name == PlanetEnvironment_name) {
             const UniverseObject* object = FollowReference(m_property_name.begin(), m_property_name.end(), m_ref_type, context);
             if (!object) {
                 Logger().errorStream() << "Variable<PlanetEnvironment>::Eval unable to follow reference: " << ReconstructName(m_property_name, m_ref_type);
@@ -367,31 +448,23 @@
     template <>
     UniverseObjectType Variable<UniverseObjectType>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(UniverseObjectType)
 
-        if (boost::iequals(property_name, "ObjectType")) {
+        if (property_name == ObjectType_name) {
             const UniverseObject* object = FollowReference(m_property_name.begin(), m_property_name.end(), m_ref_type, context);
             if (!object) {
                 Logger().errorStream() << "Variable<UniverseObjectType>::Eval unable to follow reference: " << ReconstructName(m_property_name, m_ref_type);
                 return INVALID_UNIVERSE_OBJECT_TYPE;
             }
-            if (universe_object_cast<const Planet*>(object)) {
-                return OBJ_PLANET;
-            } else if (universe_object_cast<const System*>(object)) {
-                return OBJ_SYSTEM;
-            } else if (universe_object_cast<const Building*>(object)) {
-                return OBJ_BUILDING;
-            } else if (universe_object_cast<const Ship*>(object)) {
-                return OBJ_SHIP;
-            } else if (universe_object_cast<const Fleet*>(object)) {
-                return OBJ_FLEET;
-            } else if (dynamic_cast<const PopCenter*>(object)) {
+            ObjectTypeVisitor v;
+            if (object->Accept(v))
+                return v.m_type;
+            else if (dynamic_cast<const PopCenter*>(object))
                 return OBJ_POP_CENTER;
-            } else if (dynamic_cast<const ResourceCenter*>(object)) {
+            else if (dynamic_cast<const ResourceCenter*>(object))
                 return OBJ_PROD_CENTER;
-            }
         } else {
             throw std::runtime_error("Attempted to read a non-ObjectType value \"" + ReconstructName(m_property_name, m_ref_type) + "\" using a ValueRef of type ObjectType.");
         }
@@ -401,11 +474,11 @@
     template <>
     StarType Variable<StarType>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(StarType)
 
-        if (boost::iequals(property_name, "StarType")) {
+        if (property_name == StarType_name) {
             const UniverseObject* object = FollowReference(m_property_name.begin(), m_property_name.end(), m_ref_type, context);
             if (!object) {
                 Logger().errorStream() << "Variable<StarType>::Eval unable to follow reference: " << ReconstructName(m_property_name, m_ref_type);
@@ -422,7 +495,7 @@
     template <>
     double Variable<double>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(double)
 
@@ -433,111 +506,28 @@
             return 0.0;
         }
 
-        if        (boost::iequals(property_name, "Population")) {
-            return object->InitialMeterValue(METER_POPULATION);
-        } else if (boost::iequals(property_name, "TargetPopulation")) {
-            return object->InitialMeterValue(METER_TARGET_POPULATION);
-        } else if (boost::iequals(property_name, "Health")) {
-            return object->InitialMeterValue(METER_HEALTH);
-        } else if (boost::iequals(property_name, "TargetHealth")) {
-            return object->InitialMeterValue(METER_TARGET_HEALTH);
+        MeterType meter_type = NameToMeter(property_name);
+        if        (meter_type != INVALID_METER_TYPE) {
+            return object->InitialMeterValue(meter_type);
 
-        } else if (boost::iequals(property_name, "Farming")) {
-            return object->InitialMeterValue(METER_FARMING);
-        } else if (boost::iequals(property_name, "TargetFarming")) {
-            return object->InitialMeterValue(METER_TARGET_FARMING);
-        } else if (boost::iequals(property_name, "Industry")) {
-            return object->InitialMeterValue(METER_INDUSTRY);
-        } else if (boost::iequals(property_name, "TargetIndustry")) {
-            return object->InitialMeterValue(METER_TARGET_INDUSTRY);
-        } else if (boost::iequals(property_name, "Research")) {
-            return object->InitialMeterValue(METER_RESEARCH);
-        } else if (boost::iequals(property_name, "TargetResearch")) {
-            return object->InitialMeterValue(METER_TARGET_RESEARCH);
-        } else if (boost::iequals(property_name, "Trade")) {
-            return object->InitialMeterValue(METER_TRADE);
-        } else if (boost::iequals(property_name, "TargetTrade")) {
-            return object->InitialMeterValue(METER_TARGET_TRADE);
-        } else if (boost::iequals(property_name, "Mining")) {
-            return object->InitialMeterValue(METER_MINING);
-        } else if (boost::iequals(property_name, "TargetMining")) {
-            return object->InitialMeterValue(METER_TARGET_MINING);
-        } else if (boost::iequals(property_name, "Construction")) {
-            return object->InitialMeterValue(METER_CONSTRUCTION);
-        } else if (boost::iequals(property_name, "TargetConstruction")) {
-            return object->InitialMeterValue(METER_TARGET_CONSTRUCTION);
-
-        } else if (boost::iequals(property_name, "MaxFuel")) {
-            return object->InitialMeterValue(METER_MAX_FUEL);
-        } else if (boost::iequals(property_name, "Fuel")) {
-            return object->InitialMeterValue(METER_FUEL);
-        } else if (boost::iequals(property_name, "MaxStructure")) {
-            return object->InitialMeterValue(METER_MAX_STRUCTURE);
-        } else if (boost::iequals(property_name, "Structure")) {
-            return object->InitialMeterValue(METER_STRUCTURE);
-        } else if (boost::iequals(property_name, "MaxShield")) {
-            return object->InitialMeterValue(METER_MAX_SHIELD);
-        } else if (boost::iequals(property_name, "Shield")) {
-            return object->InitialMeterValue(METER_SHIELD);
-        } else if (boost::iequals(property_name, "MaxDefense")) {
-            return object->InitialMeterValue(METER_MAX_DEFENSE);
-        } else if (boost::iequals(property_name, "Defense")) {
-            return object->InitialMeterValue(METER_DEFENSE);
-        } else if (boost::iequals(property_name, "MaxTroops")) {
-            return object->InitialMeterValue(METER_MAX_TROOPS);
-        } else if (boost::iequals(property_name, "Troops")) {
-            return object->InitialMeterValue(METER_TROOPS);
-
-        } else if (boost::iequals(property_name, "FoodConsumption")) {
-            return object->InitialMeterValue(METER_FOOD_CONSUMPTION);
-        } else if (boost::iequals(property_name, "Supply")) {
-            return object->InitialMeterValue(METER_SUPPLY);
-        } else if (boost::iequals(property_name, "Stealth")) {
-            return object->InitialMeterValue(METER_STEALTH);
-        } else if (boost::iequals(property_name, "Detection")) {
-            return object->InitialMeterValue(METER_DETECTION);
-        } else if (boost::iequals(property_name, "BattleSpeed")) {
-            return object->InitialMeterValue(METER_BATTLE_SPEED);
-        } else if (boost::iequals(property_name, "StarlaneSpeed")) {
-            return object->InitialMeterValue(METER_STARLANE_SPEED);
-
-        } else if (boost::iequals(property_name, "Damage")) {
-            return object->InitialMeterValue(METER_DAMAGE);
-        } else if (boost::iequals(property_name, "ROF")) {
-            return object->InitialMeterValue(METER_ROF);
-        } else if (boost::iequals(property_name, "Range")) {
-            return object->InitialMeterValue(METER_RANGE);
-        } else if (boost::iequals(property_name, "Speed")) {
-            return object->InitialMeterValue(METER_SPEED);
-        } else if (boost::iequals(property_name, "Capacity")) {
-            return object->InitialMeterValue(METER_CAPACITY);
-        } else if (boost::iequals(property_name, "AntiShipDamage")) {
-            return object->InitialMeterValue(METER_ANTI_SHIP_DAMAGE);
-        } else if (boost::iequals(property_name, "AntiFighterDamage")) {
-            return object->InitialMeterValue(METER_ANTI_FIGHTER_DAMAGE);
-        } else if (boost::iequals(property_name, "LaunchRate")) {
-            return object->InitialMeterValue(METER_LAUNCH_RATE);
-        } else if (boost::iequals(property_name, "FighterWeaponRange")) {
-            return object->InitialMeterValue(METER_FIGHTER_WEAPON_RANGE);
-
-        } else if (boost::iequals(property_name, "TradeStockpile")) {
+        } else if (property_name == TradeStockpile_name) {
             if (const Empire* empire = Empires().Lookup(object->Owner()))
                 return empire->ResourceStockpile(RE_TRADE);
-        } else if (boost::iequals(property_name, "MineralStockpile")) {
+        } else if (property_name == MineralStockpile_name) {
             if (const Empire* empire = Empires().Lookup(object->Owner()))
                 return empire->ResourceStockpile(RE_MINERALS);
-        } else if (boost::iequals(property_name, "FoodStockpile")) {
+        } else if (property_name == FoodStockpile_name) {
             if (const Empire* empire = Empires().Lookup(object->Owner()))
                 return empire->ResourceStockpile(RE_FOOD);
 
-        } else if (boost::iequals(property_name, "AllocatedFood")) {
+        } else if (property_name == AllocatedFood_name) {
             if (const PopCenter* pop = dynamic_cast<const PopCenter*>(object))
                 return pop->AllocatedFood();
-        } else if (boost::iequals(property_name, "FoodAllocationForMaxGrowth")) {
+        } else if (property_name == FoodAllocationForMaxGrowth_name) {
             if (const PopCenter* pop = dynamic_cast<const PopCenter*>(object))
                 return pop->FoodAllocationForMaxGrowth();
 
-        } else if (boost::iequals(property_name, "DistanceToSource")) {
+        } else if (property_name == DistanceToSource_name) {
             if (!context.source) {
                 Logger().errorStream() << "ValueRef::Variable<double>::Eval can't find distance to source because no source was passed";
                 return 0.0;
@@ -556,7 +546,7 @@
     template <>
     int Variable<int>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(int)
 
@@ -566,64 +556,64 @@
             return 0;
         }
 
-        if (boost::iequals(property_name, "Owner")) {
+        if (property_name == Owner_name) {
             return object->Owner();
-        } else if (boost::iequals(property_name, "ID")) {
+        } else if (property_name == ID_name) {
             return object->ID();
-        } else if (boost::iequals(property_name, "CreationTurn")) {
+        } else if (property_name == CreationTurn_name) {
             return object->CreationTurn();
-        } else if (boost::iequals(property_name, "Age")) {
+        } else if (property_name == Age_name) {
             return object->AgeInTurns();
-        } else if (boost::iequals(property_name, "ProducedByEmpireID")) {
+        } else if (property_name == ProducedByEmpireID_name) {
             if (const Ship* ship = universe_object_cast<const Ship*>(object))
                 return ship->ProducedByEmpireID();
             else if (const Building* building = universe_object_cast<const Building*>(object))
                 return building->ProducedByEmpireID();
             else
                 return ALL_EMPIRES;
-        } else if (boost::iequals(property_name, "DesignID")) {
+        } else if (property_name == DesignID_name) {
             if (const Ship* ship = universe_object_cast<const Ship*>(object))
                 return ship->DesignID();
             else
                 return ShipDesign::INVALID_DESIGN_ID;
-        } else if (boost::iequals(property_name, "FleetID")) {
+        } else if (property_name == FleetID_name) {
             if (const Ship* ship = universe_object_cast<const Ship*>(object))
                 return ship->FleetID();
             else
                 return UniverseObject::INVALID_OBJECT_ID;
-        } else if (boost::iequals(property_name, "PlanetID")) {
+        } else if (property_name == PlanetID_name) {
             if (const Building* building = universe_object_cast<const Building*>(object))
                 return building->PlanetID();
             else
                 return UniverseObject::INVALID_OBJECT_ID;
-        } else if (boost::iequals(property_name, "SystemID")) {
+        } else if (property_name == SystemID_name) {
             return object->SystemID();
-        } else if (boost::iequals(property_name, "FinalDestinationID")) {
+        } else if (property_name == FinalDestinationID_name) {
             if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
                 return fleet->FinalDestinationID();
             else
                 return UniverseObject::INVALID_OBJECT_ID;
-        } else if (boost::iequals(property_name, "NextSystemID")) {
+        } else if (property_name == NextSystemID_name) {
             if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
                 return fleet->NextSystemID();
             else
                 return UniverseObject::INVALID_OBJECT_ID;
-        } else if (boost::iequals(property_name, "PreviousSystemID")) {
+        } else if (property_name == PreviousSystemID_name) {
             if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
                 return fleet->PreviousSystemID();
             else
                 return UniverseObject::INVALID_OBJECT_ID;
-        } else if (boost::iequals(property_name, "NumShips")) {
+        } else if (property_name == NumShips_name) {
             if (const Fleet* fleet = universe_object_cast<const Fleet*>(object))
                 return fleet->NumShips();
             else
                 return 0;
-        } else if (boost::iequals(property_name, "LastTurnBattleHere")) {
+        } else if (property_name == LastTurnBattleHere_name) {
             if (const System* system = universe_object_cast<const System*>(object))
                 return system->LastTurnBattleHere();
             else
                 return INVALID_GAME_TURN;
-        } else if (boost::iequals(property_name, "CurrentTurn")) {
+        } else if (property_name == CurrentTurn_name) {
             return CurrentTurn();
         } else {
             throw std::runtime_error("Attempted to read a non-int value \"" + ReconstructName(m_property_name, m_ref_type) + "\" using a ValueRef of type int.");
@@ -635,7 +625,7 @@
     template <>
     std::string Variable<std::string>::Eval(const ScriptingContext& context) const
     {
-        const std::string& property_name = m_property_name.back();
+        const adobe::name_t& property_name = m_property_name.back();
 
         IF_CURRENT_VALUE(std::string)
 
@@ -645,17 +635,17 @@
             return "";
         }
 
-        if (boost::iequals(property_name, "Name")) {
+        if (property_name == Name_name) {
             return object->Name();
-        } else if (boost::iequals(property_name, "Species")) {
+        } else if (property_name == Species_name) {
             if (const Planet* planet = universe_object_cast<const Planet*>(object))
                 return planet->SpeciesName();
             else if (const Ship* ship = universe_object_cast<const Ship*>(object))
                 return ship->SpeciesName();
-        } else if (boost::iequals(property_name, "BuildingType")) {
+        } else if (property_name == BuildingType_name) {
             if (const Building* building = universe_object_cast<const Building*>(object))
                 return building->BuildingTypeName();
-        } else if (boost::iequals(property_name, "Focus")) {
+        } else if (property_name == Focus_name) {
             if (const Planet* planet = universe_object_cast<const Planet*>(object))
                 return planet->Focus();
         } else {
Index: universe/Tech.cpp
===================================================================
--- universe/Tech.cpp	(revision 4463)
+++ universe/Tech.cpp	(working copy)
@@ -1,8 +1,7 @@
 #include "Tech.h"
 
 #include "Effect.h"
-#include "../universe/Parser.h"
-#include "../universe/ParserUtil.h"
+#include "../parse/Parse.h"
 #include "../util/MultiplayerCommon.h"
 #include "../util/OptionsDB.h"
 #include "../util/AppInterface.h"
@@ -104,9 +103,6 @@
 
         return next_techs[min_index];
     }
-
-    const phoenix::function<store_tech_impl> store_tech_;
-    const phoenix::function<store_category_impl> store_category_;
 }
 
 
@@ -403,33 +399,9 @@
 
     s_instance = this;
 
-    std::string file_name = "techs.txt";
-    std::string input;
-
-    boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-    if (ifs) {
-        std::getline(ifs, input, '\0');
-        ifs.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << file_name;
-        return;
-    }
-
-    using namespace boost::spirit::classic;
-    using namespace phoenix;
-
     std::set<std::string> categories_seen_in_techs;
 
-    parse_info<const char*> result =
-        parse(input.c_str(),
-              as_lower_d[*(
-                            tech_p[store_tech_(var(m_techs), var(categories_seen_in_techs), arg1)] |
-                            category_p[store_category_(var(m_categories), arg1)]
-                          )]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
+    parse::techs(GetResourceDir() / "techs.txt", m_techs, m_categories, categories_seen_in_techs);
 
     std::set<std::string> empty_defined_categories;
     for (std::map<std::string, TechCategory*>::iterator map_it = m_categories.begin(); map_it != m_categories.end(); ++map_it) {
Index: universe/ShipDesign.cpp
===================================================================
--- universe/ShipDesign.cpp	(revision 4463)
+++ universe/ShipDesign.cpp	(working copy)
@@ -4,9 +4,9 @@
 #include "../util/MultiplayerCommon.h"
 #include "../util/OptionsDB.h"
 #include "../util/Directories.h"
+#include "../parse/Parse.h"
 #include "../Empire/Empire.h"
 #include "../Empire/EmpireManager.h"
-#include "ParserUtil.h"
 #include "Condition.h"
 #include "Effect.h"
 #include "ValueRef.h"
@@ -24,51 +24,6 @@
 }
 
 namespace {
-    struct store_ship_design_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::map<std::string, ShipDesign*>& ship_designs, const T& ship_design) const {
-            if (ship_designs.find(ship_design->Name(false)) != ship_designs.end()) {
-                std::string error_str = "ERROR: More than one predefined ship design in predefined_ship_designs.txt has the name " + ship_design->Name(false);
-                throw std::runtime_error(error_str.c_str());
-            }
-            ship_designs[ship_design->Name(false)] = ship_design;
-        }
-    };
-
-    const phoenix::function<store_ship_design_impl> store_ship_design_;
-
-    struct store_part_type_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::map<std::string, PartType*>& part_types, const T& part_type) const {
-            if (part_types.find(part_type->Name()) != part_types.end()) {
-                std::string error_str = "ERROR: More than one ship part in ship_parts.txt has the name " + part_type->Name();
-                throw std::runtime_error(error_str.c_str());
-            }
-            part_types[part_type->Name()] = part_type;
-        }
-    };
-
-    const phoenix::function<store_part_type_impl> store_part_type_;
-
-    struct store_hull_type_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::map<std::string, HullType*>& hull_types, const T& hull_type) const {
-            if (hull_types.find(hull_type->Name()) != hull_types.end()) {
-                std::string error_str = "ERROR: More than one ship hull in ship_hulls.txt has the name " + hull_type->Name();
-                throw std::runtime_error(error_str.c_str());
-            }
-            hull_types[hull_type->Name()] = hull_type;
-        }
-    };
-
-    const phoenix::function<store_hull_type_impl> store_hull_type_;
-
     struct PartTypeStringVisitor :
         public boost::static_visitor<>
     {
@@ -233,30 +188,11 @@
 PartTypeManager::PartTypeManager() {
     if (s_instance)
         throw std::runtime_error("Attempted to create more than one PartTypeManager.");
+
     s_instance = this;
 
-    std::string file_name = "ship_parts.txt";
-    std::string input;
+    parse::ship_parts(GetResourceDir() / "ship_parts.txt", m_parts);
 
-    boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-    if (ifs) {
-        std::getline(ifs, input, '\0');
-        ifs.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << file_name;
-        return;
-    }
-
-    using namespace boost::spirit::classic;
-    using namespace phoenix;
-    parse_info<const char*> result =
-        parse(input.c_str(),
-              as_lower_d[*part_p[store_part_type_(var(m_parts), arg1)]]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
-
     if (GetOptionsDB().Get<bool>("verbose-logging")) {
         Logger().debugStream() << "Part Types:";
         for (iterator it = begin(); it != end(); ++it) {
@@ -815,30 +751,11 @@
 HullTypeManager::HullTypeManager() {
     if (s_instance)
         throw std::runtime_error("Attempted to create more than one HullTypeManager.");
+
     s_instance = this;
 
-    std::string file_name = "ship_hulls.txt";
-    std::string input;
+    parse::ship_hulls(GetResourceDir() / "ship_hulls.txt", m_hulls);
 
-    boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-    if (ifs) {
-        std::getline(ifs, input, '\0');
-        ifs.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << file_name;
-        return;
-    }
-
-    using namespace boost::spirit::classic;
-    using namespace phoenix;
-    parse_info<const char*> result =
-        parse(input.c_str(),
-              as_lower_d[*hull_p[store_hull_type_(var(m_hulls), arg1)]]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
-
     if (GetOptionsDB().Get<bool>("verbose-logging")) {
         Logger().debugStream() << "Hull Types:";
         for (iterator it = begin(); it != end(); ++it) {
@@ -1473,53 +1390,10 @@
 
     Logger().debugStream() << "Initializing PredefinedShipDesignManager";
 
-    using namespace boost::spirit::classic;
-    using namespace phoenix;
-    std::string input;
-    parse_info<const char*> result;
+    parse::ship_designs(GetResourceDir() / "premade_ship_designs.txt", m_ship_designs);
 
+    parse::ship_designs(GetResourceDir() / "space_monsters.txt", m_monster_designs);
 
-    // load start of game ship designs
-    std::string designs_file_name = "premade_ship_designs.txt";
-
-    boost::filesystem::ifstream ifs(GetResourceDir() / designs_file_name);
-    if (ifs) {
-        std::getline(ifs, input, '\0');
-        ifs.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << designs_file_name;
-        return;
-    }
-
-    result =
-        parse(input.c_str(),
-              as_lower_d[*ship_design_p[store_ship_design_(var(m_ship_designs), arg1)]]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
-
-
-    // Load space monster ship designs
-    std::string monsters_file_name = "space_monsters.txt";
-
-    boost::filesystem::ifstream ifs2(GetResourceDir() / monsters_file_name);
-    if (ifs2) {
-        std::getline(ifs2, input, '\0');
-        ifs2.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << monsters_file_name;
-        return;
-    }
-
-    result =
-        parse(input.c_str(),
-              as_lower_d[*ship_design_p[store_ship_design_(var(m_monster_designs), arg1)]]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
-
     if (GetOptionsDB().Get<bool>("verbose-logging")) {
         Logger().debugStream() << "Predefined Ship Designs:";
         for (iterator it = begin(); it != end(); ++it) {
Index: universe/Names.cpp
===================================================================
--- universe/Names.cpp	(revision 0)
+++ universe/Names.cpp	(revision 0)
@@ -0,0 +1,9 @@
+#include "Names.h"
+
+#include <boost/preprocessor/stringize.hpp>
+
+
+#define DEFINE_NAME(r, _, name) adobe::aggregate_name_t BOOST_PP_CAT(name, _name) = { BOOST_PP_STRINGIZE(name) };
+BOOST_PP_SEQ_FOR_EACH(DEFINE_NAME, _, NAMES_SEQ_1)
+BOOST_PP_SEQ_FOR_EACH(DEFINE_NAME, _, NAMES_SEQ_2)
+#undef DEFINE_NAME
Index: universe/ValueRef.h
===================================================================
--- universe/ValueRef.h	(revision 4463)
+++ universe/ValueRef.h	(working copy)
@@ -3,10 +3,13 @@
 #define _ValueRef_h_
 
 #include "Enums.h"
+#include "Condition.h"
+#include "Names.h"
 #include "ValueRefFwd.h"
-#include "Condition.h"
 #include "../util/MultiplayerCommon.h"
 
+#include <GG/adobe/name.hpp>
+
 #include <boost/algorithm/string/case_conv.hpp>
 #include <boost/format.hpp>
 #include <boost/mpl/if.hpp>
@@ -61,10 +64,6 @@
     const boost::any        current_value;
 };
 
-namespace detail {
-    std::vector<std::string> TokenizeDottedReference(const std::string& str);
-}
-
 /** The base class for all ValueRef classes.  This class provides the public
   * interface for a ValueRef expression tree. */
 template <class T>
@@ -125,14 +124,14 @@
 template <class T>
 struct ValueRef::Variable : public ValueRef::ValueRefBase<T>
 {
-    /** basic ctor.  If \a ref_type is true, the field corresponding to
-      * \a property_name is read from the \a source parameter of Eval;
-      * otherwise, the same field is read from Eval's \a target parameter. */
+    /** Deprecated ctor, used by old parser. TODO: Remove. */
     Variable(ReferenceType ref_type, const std::string& property_name);
 
-    ReferenceType                   GetReferenceType() const;
-    const std::vector<std::string>& PropertyName() const;
+    Variable(const std::vector<adobe::name_t>& property_name);
 
+    ReferenceType                     GetReferenceType() const;
+    const std::vector<adobe::name_t>& PropertyName() const;
+
     virtual T                       Eval(const ScriptingContext& context) const;
 
     virtual bool                    RootCandidateInvariant() const;
@@ -143,11 +142,14 @@
     virtual std::string             Dump() const;
 
 protected:
+    /** Deprecated ctor, used by old parser. TODO: Remove. */
     Variable(ReferenceType ref_type, const std::vector<std::string>& property_name);
 
+    Variable(ReferenceType ref_type, const std::vector<adobe::name_t>& property_name);
+
 private:
     ReferenceType                   m_ref_type;
-    std::vector<std::string>        m_property_name;
+    std::vector<adobe::name_t>      m_property_name;
 
     friend class boost::serialization::access;
     template <class Archive>
@@ -162,10 +164,15 @@
 template <class T>
 struct ValueRef::Statistic : public ValueRef::Variable<T>
 {
+    /** Deprecated ctor, used by old parser. TODO: Remove. */
     Statistic(const std::string& property_name,
               StatisticType stat_type,
               const Condition::ConditionBase* sampling_condition);
 
+    Statistic(const std::vector<adobe::name_t>& property_name,
+              StatisticType stat_type,
+              const Condition::ConditionBase* sampling_condition);
+
     StatisticType                   GetStatisticType() const;
     const Condition::ConditionBase* SamplingCondition() const;
 
@@ -179,6 +186,7 @@
     virtual std::string             Dump() const;
 
 protected:
+    /** Deprecated ctor, used by old parser. TODO: Remove. */
     Statistic(const std::vector<std::string>& property_name,
               StatisticType stat_type,
               const Condition::ConditionBase* sampling_condition);
@@ -290,7 +298,7 @@
 std::string DumpIndent();
 
 namespace ValueRef {
-    std::string ReconstructName(const std::vector<std::string>& property_name,
+    std::string ReconstructName(const std::vector<adobe::name_t>& property_name,
                                 ReferenceType ref_type);
 }
 
@@ -366,27 +374,74 @@
         & BOOST_SERIALIZATION_NVP(m_value);
 }
 
+namespace detail {
+    std::vector<std::string> TokenizeDottedReference(const std::string& str); // TODO: Remove.
+    std::vector<adobe::name_t> PrependNonObject(const std::vector<adobe::name_t>& property_name);
+}
+
 ///////////////////////////////////////////////////////////
 // Variable                                              //
 ///////////////////////////////////////////////////////////
 template <class T>
 ValueRef::Variable<T>::Variable(ReferenceType ref_type, const std::string& property_name) :
     m_ref_type(ref_type),
-    m_property_name(::detail::TokenizeDottedReference(property_name))
-{}
+    m_property_name()
+{
+    const std::vector<std::string>& string_vec = ::detail::TokenizeDottedReference(property_name);
+    adobe::name_t ref_type_name(string_vec[0].c_str());
+    if (ref_type_name == NonObject_name) {
+        m_ref_type = NON_OBJECT_REFERENCE;
+    } else if (ref_type_name == Source_name) {
+        m_ref_type = SOURCE_REFERENCE;
+    } else if (ref_type_name == Target_name) {
+        m_ref_type = EFFECT_TARGET_REFERENCE;
+    } else if (ref_type_name == LocalCandidate_name) {
+        m_ref_type = CONDITION_LOCAL_CANDIDATE_REFERENCE;
+    } else if (ref_type_name == RootCandidate_name) {
+        m_ref_type = CONDITION_ROOT_CANDIDATE_REFERENCE;
+    }
+    for (std::size_t i = 1; i < string_vec.size(); ++i) {
+        m_property_name.push_back(adobe::name_t(string_vec[i].c_str()));
+    }
+}
 
 template <class T>
+ValueRef::Variable<T>::Variable(const std::vector<adobe::name_t>& property_name) :
+    m_ref_type(),
+    m_property_name(property_name.begin() + 1, property_name.end())
+{
+    adobe::name_t ref_type_name = property_name.front();
+    if (ref_type_name == NonObject_name) {
+        m_ref_type = NON_OBJECT_REFERENCE;
+    } else if (ref_type_name == Source_name) {
+        m_ref_type = SOURCE_REFERENCE;
+    } else if (ref_type_name == Target_name) {
+        m_ref_type = EFFECT_TARGET_REFERENCE;
+    } else if (ref_type_name == LocalCandidate_name) {
+        m_ref_type = CONDITION_LOCAL_CANDIDATE_REFERENCE;
+    } else if (ref_type_name == RootCandidate_name) {
+        m_ref_type = CONDITION_ROOT_CANDIDATE_REFERENCE;
+    }
+}
+
+template <class T>
 ValueRef::Variable<T>::Variable(ReferenceType ref_type, const std::vector<std::string>& property_name) :
     m_ref_type(ref_type),
     m_property_name(property_name)
 {}
 
 template <class T>
+ValueRef::Variable<T>::Variable(ReferenceType ref_type, const std::vector<adobe::name_t>& property_name) :
+    m_ref_type(ref_type),
+    m_property_name(property_name)
+{}
+
+template <class T>
 ValueRef::ReferenceType ValueRef::Variable<T>::GetReferenceType() const
 { return m_ref_type; }
 
 template <class T>
-const std::vector<std::string>& ValueRef::Variable<T>::PropertyName() const
+const std::vector<adobe::name_t>& ValueRef::Variable<T>::PropertyName() const
 { return m_property_name; }
 
 template <class T>
@@ -414,7 +469,7 @@
     default:                                    formatter % "???";                                  break;
     }
     for (unsigned int i = 0; i < m_property_name.size(); ++i)
-        formatter % UserString("DESC_VAR_" + boost::to_upper_copy(m_property_name[i]));
+        formatter % UserString("DESC_VAR_" + boost::to_upper_copy(std::string(m_property_name[i].c_str())));
     return boost::io::str(formatter);
 }
 
@@ -450,8 +505,8 @@
 void ValueRef::Variable<T>::serialize(Archive& ar, const unsigned int version)
 {
     ar  & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ValueRefBase)
-        & BOOST_SERIALIZATION_NVP(m_ref_type)
-        & BOOST_SERIALIZATION_NVP(m_property_name);
+        & BOOST_SERIALIZATION_NVP(m_ref_type)/* TODO
+        & BOOST_SERIALIZATION_NVP(m_property_name)*/;
 }
 
 ///////////////////////////////////////////////////////////
@@ -469,6 +524,15 @@
 }
 
 template <class T>
+ValueRef::Statistic<T>::Statistic(const std::vector<adobe::name_t>& property_name,
+                                  StatisticType stat_type,
+                                  const Condition::ConditionBase* sampling_condition) :
+    Variable<T>(ValueRef::NON_OBJECT_REFERENCE, property_name),
+    m_stat_type(stat_type),
+    m_sampling_condition(sampling_condition)
+{}
+
+template <class T>
 ValueRef::Statistic<T>::Statistic(const std::vector<std::string>& property_name,
                                   StatisticType stat_type,
                                   const Condition::ConditionBase* sampling_condition) :
Index: universe/ValueRefFwd.h
===================================================================
--- universe/ValueRefFwd.h	(revision 4463)
+++ universe/ValueRefFwd.h	(working copy)
@@ -19,6 +19,7 @@
     template <class T> struct Variable;
     template <class T> struct Statistic;
     enum StatisticType {
+        INVALID_STATISTIC_TYPE = -1,
         COUNT,  // returns the number of objects matching the condition
         SUM,    // returns the sum of the property values of all objects matching the condition
         MEAN,   // returns the mean of the property values of all objects matching the condition
Index: universe/Special.cpp
===================================================================
--- universe/Special.cpp	(revision 4463)
+++ universe/Special.cpp	(working copy)
@@ -1,8 +1,8 @@
 #include "Special.h"
 
-#include "ParserUtil.h"
 #include "Effect.h"
 #include "Condition.h"
+#include "../parse/Parse.h"
 #include "../util/MultiplayerCommon.h"
 #include "../util/OptionsDB.h"
 #include "../util/Directories.h"
@@ -14,48 +14,10 @@
 extern int g_indent;
 
 namespace {
-    struct store_special_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::map<std::string, Special*>& specials, const T& special) const {
-            if (specials.find(special->Name()) != specials.end()) {
-                std::string error_str = "ERROR: More than one special in specials.txt has the name " + special->Name();
-                throw std::runtime_error(error_str.c_str());
-            }
-            specials[special->Name()] = special;
-        }
-    };
-    const phoenix::function<store_special_impl> store_special_;
-
     class SpecialManager {
     public:
         SpecialManager() {
-            std::string input, file_name("specials.txt");
-            boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-            if (ifs) {
-                std::getline(ifs, input, '\0');
-                ifs.close();
-            } else {
-                Logger().errorStream() << "Unable to open data file " << file_name;
-                return;
-            }
-            using namespace boost::spirit::classic;
-            using namespace phoenix;
-            parse_info<const char*> result =
-                parse(input.c_str(),
-                      as_lower_d[*special_p[store_special_(var(m_specials), arg1)]]
-                      >> end_p,
-                      skip_p);
-            if (!result.full)
-                ReportError(input.c_str(), result);
-
-            //Logger().debugStream() << "Specials:";
-            //for (std::map<std::string, Special*>::const_iterator it = m_specials.begin(); it != m_specials.end(); ++it)
-            //    Logger().debugStream() << " ... " << it->second->Name() <<
-            //                              " spawn rate: " << it->second->SpawnRate() <<
-            //                              " spawn limit: " << it->second->SpawnLimit() <<
-            //                              " location: " << (it->second->Location() ? it->second->Location()->Dump() : "none");
+            parse::specials(GetResourceDir() / "specials.txt", m_specials);
         }
         ~SpecialManager() {
             for (std::map<std::string, Special*>::iterator it = m_specials.begin();
Index: universe/Tech.h
===================================================================
--- universe/Tech.h	(revision 4463)
+++ universe/Tech.h	(working copy)
@@ -141,7 +141,7 @@
     given a set of currently-known techs. */
 class TechManager
 {
-private:
+public:
     struct CategoryIndex {};
     struct NameIndex {};
     typedef boost::multi_index_container<
@@ -166,7 +166,6 @@
         >
     > TechContainer;
 
-public:
     /** iterator that runs over techs within a category */
     typedef TechContainer::index<CategoryIndex>::type::const_iterator category_iterator;
 
Index: universe/Species.cpp
===================================================================
--- universe/Species.cpp	(revision 4463)
+++ universe/Species.cpp	(working copy)
@@ -1,8 +1,8 @@
 #include "Species.h"
 
-#include "ParserUtil.h"
 #include "Effect.h"
 #include "Condition.h"
+#include "../parse/Parse.h"
 #include "../util/MultiplayerCommon.h"
 #include "../util/Directories.h"
 #include "../util/Random.h"
@@ -13,26 +13,7 @@
 
 extern int g_indent;
 
-namespace {
-    struct store_species_impl
-    {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::map<std::string, Species*>& species_map, const T& species) const
-        {
-            if (species_map.find(species->Name()) != species_map.end()) {
-                std::string error_str = "ERROR: More than one species in species.txt has the name " + species->Name();
-                throw std::runtime_error(error_str.c_str());
-            }
-            species_map[species->Name()] = species;
-        }
-    };
 
-    const phoenix::function<store_species_impl> store_species_;
-}
-
-
 /////////////////////////////////////////////////
 // FocusType                                   //
 /////////////////////////////////////////////////
@@ -345,27 +326,7 @@
 
     s_instance = this;
 
-    std::string file_name = "species.txt";
-    std::string input;
-
-    boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-    if (ifs) {
-        std::getline(ifs, input, '\0');
-        ifs.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << file_name;
-        return;
-    }
-
-    using namespace boost::spirit::classic;
-    using namespace phoenix;
-    parse_info<const char*> result =
-        parse(input.c_str(),
-              as_lower_d[*species_p[store_species_(var(m_species), arg1)]]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
+    parse::species(GetResourceDir() / "species.txt", m_species);
 }
 
 SpeciesManager::~SpeciesManager() {
Index: universe/Effect.cpp
===================================================================
--- universe/Effect.cpp	(revision 4463)
+++ universe/Effect.cpp	(working copy)
@@ -38,7 +38,7 @@
                     if (!meter_str.empty())
                         meter_str[0] = std::toupper(meter_str[0]);
                     retval.get<0>() = var->PropertyName().size() == 1 &&
-                        ("Current" + meter_str) == var->PropertyName()[0];
+                        adobe::name_t(("Current" + meter_str).c_str()) == var->PropertyName()[0];
                     retval.get<1>() = op->GetOpType();
                     retval.get<2>() = constant->Value();
                     return retval;
@@ -49,7 +49,7 @@
                     if (!meter_str.empty())
                         meter_str[0] = std::toupper(meter_str[0]);
                     retval.get<0>() = var->PropertyName().size() == 1 &&
-                        ("Current" + meter_str) == var->PropertyName()[0];
+                        adobe::name_t(("Current" + meter_str).c_str()) == var->PropertyName()[0];
                     retval.get<1>() = op->GetOpType();
                     retval.get<2>() = constant->Value();
                     return retval;
Index: universe/Building.cpp
===================================================================
--- universe/Building.cpp	(revision 4463)
+++ universe/Building.cpp	(working copy)
@@ -6,11 +6,10 @@
 #include "Predicates.h"
 #include "Universe.h"
 #include "Enums.h"
-#include "Parser.h"
-#include "ParserUtil.h"
 #include "ValueRef.h"
 #include "../Empire/Empire.h"
 #include "../Empire/EmpireManager.h"
+#include "../parse/Parse.h"
 #include "../util/MultiplayerCommon.h"
 #include "../util/OptionsDB.h"
 #include "../util/AppInterface.h"
@@ -26,23 +25,6 @@
     const bool CHEAP_AND_FAST_BUILDING_PRODUCTION = false;    // makes all buildings cost 1 PP and take 1 turn to build
 }
 
-namespace {
-    struct store_building_type_impl {
-        template <class T1, class T2>
-        struct result {typedef void type;};
-        template <class T>
-        void operator()(std::map<std::string, BuildingType*>& building_types, const T& building_type) const {
-            if (building_types.find(building_type->Name()) != building_types.end()) {
-                std::string error_str = "ERROR: More than one building type in buildings.txt has the name " + building_type->Name();
-                throw std::runtime_error(error_str.c_str());
-            }
-            building_types[building_type->Name()] = building_type;
-        }
-    };
-
-    const phoenix::function<store_building_type_impl> store_building_type_;
-}
-
 /////////////////////////////////////////////////
 // Building                                    //
 /////////////////////////////////////////////////
@@ -344,27 +326,7 @@
 
     s_instance = this;
 
-    std::string file_name = "buildings.txt";
-    std::string input;
-
-    boost::filesystem::ifstream ifs(GetResourceDir() / file_name);
-    if (ifs) {
-        std::getline(ifs, input, '\0');
-        ifs.close();
-    } else {
-        Logger().errorStream() << "Unable to open data file " << file_name;
-        return;
-    }
-
-    using namespace boost::spirit::classic;
-    using namespace phoenix;
-    parse_info<const char*> result =
-        parse(input.c_str(),
-              as_lower_d[*building_type_p[store_building_type_(var(m_building_types), arg1)]]
-              >> end_p,
-              skip_p);
-    if (!result.full)
-        ReportError(input.c_str(), result);
+    parse::buildings(GetResourceDir() / "buildings.txt", m_building_types);
 }
 
 BuildingTypeManager::~BuildingTypeManager()
Index: server/CMakeLists.txt
===================================================================
--- server/CMakeLists.txt	(revision 4463)
+++ server/CMakeLists.txt	(working copy)
@@ -23,6 +23,37 @@
     ../network/Message.cpp
     ../network/MessageQueue.cpp
     ../network/Networking.cpp
+    ../parse/AlignmentsParser.cpp
+    ../parse/BuildingsParser.cpp
+    ../parse/ConditionParser1.cpp
+    ../parse/ConditionParser2.cpp
+    ../parse/ConditionParser3.cpp
+    ../parse/ConditionParser.cpp
+    ../parse/Double.cpp
+    ../parse/DoubleValueRefParser.cpp
+    ../parse/EffectParser.cpp
+    ../parse/EnumParser.cpp
+    ../parse/FleetPlansParser.cpp
+    ../parse/Int.cpp
+    ../parse/IntValueRefParser.cpp
+    ../parse/ItemsParser.cpp
+    ../parse/Label.cpp
+    ../parse/Lexer.cpp
+    ../parse/MonsterFleetPlansParser.cpp
+    ../parse/Parse.cpp
+    ../parse/PlanetEnvironmentValueRefParser.cpp
+    ../parse/PlanetSizeValueRefParser.cpp
+    ../parse/PlanetTypeValueRefParser.cpp
+    ../parse/ReportParseError.cpp
+    ../parse/ShipDesignsParser.cpp
+    ../parse/ShipHullsParser.cpp
+    ../parse/ShipPartsParser.cpp
+    ../parse/SpecialsParser.cpp
+    ../parse/SpeciesParser.cpp
+    ../parse/StarTypeValueRefParser.cpp
+    ../parse/StringValueRefParser.cpp
+    ../parse/TechsParser.cpp
+    ../parse/UniverseObjectTypeValueRefParser.cpp
     ../UI/StringTable.cpp
     ../universe/Building.cpp
     ../universe/Condition.cpp
@@ -36,6 +67,7 @@
     ../universe/Enums.cpp
     ../universe/Fleet.cpp
     ../universe/Meter.cpp
+    ../universe/Names.cpp
     ../universe/ObjectMap.cpp
     ../universe/ParserUtil.cpp
     ../universe/Planet.cpp
@@ -112,7 +144,7 @@
     link_directories(${BOOST_LIBRARYDIR})
     set(THIS_EXE_LINK_LIBS ${GIGI_GIGI_LIBRARY} ${ZLIB_LIBRARY})
 else ()
-    set(THIS_EXE_LINK_LIBS ${Boost_LIBRARIES} ${ZLIB_LIBRARY})
+    set(THIS_EXE_LINK_LIBS ${GIGI_GIGI_LIBRARY} ${Boost_LIBRARIES} ${ZLIB_LIBRARY})
 endif ()
 
 executable_all_variants(freeoriond)
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 4463)
+++ CMakeLists.txt	(working copy)
@@ -15,7 +15,7 @@
 include(Config)
 include(Util)
 
-set(MINIMUM_BOOST_VERSION 1.44.0)
+set(MINIMUM_BOOST_VERSION 1.47.0)
 set(MINIMUM_BOOST_COMPONENTS date_time filesystem serialization signals system thread)
 
 set(BOOST_SIGNALS_NAMESPACE "signals" CACHE STRING
@@ -333,6 +333,13 @@
 add_subdirectory(client/AI)
 add_subdirectory(client/human)
 
+option(BUILD_PARSER_TESTS "Controls generation of parser unit tests." OFF)
+
+if (BUILD_PARSER_TESTS)
+    enable_testing()
+    add_subdirectory(parse)
+endif ()
+
 ########################################
 # Win32 SDK-only steps                 #
 ########################################
Index: client/human/CMakeLists.txt
===================================================================
--- client/human/CMakeLists.txt	(revision 4463)
+++ client/human/CMakeLists.txt	(working copy)
@@ -85,6 +85,37 @@
     ../../network/Message.cpp
     ../../network/MessageQueue.cpp
     ../../network/Networking.cpp
+    ../../parse/AlignmentsParser.cpp
+    ../../parse/BuildingsParser.cpp
+    ../../parse/ConditionParser1.cpp
+    ../../parse/ConditionParser2.cpp
+    ../../parse/ConditionParser3.cpp
+    ../../parse/ConditionParser.cpp
+    ../../parse/Double.cpp
+    ../../parse/DoubleValueRefParser.cpp
+    ../../parse/EffectParser.cpp
+    ../../parse/EnumParser.cpp
+    ../../parse/FleetPlansParser.cpp
+    ../../parse/Int.cpp
+    ../../parse/IntValueRefParser.cpp
+    ../../parse/ItemsParser.cpp
+    ../../parse/Label.cpp
+    ../../parse/Lexer.cpp
+    ../../parse/MonsterFleetPlansParser.cpp
+    ../../parse/Parse.cpp
+    ../../parse/PlanetEnvironmentValueRefParser.cpp
+    ../../parse/PlanetSizeValueRefParser.cpp
+    ../../parse/PlanetTypeValueRefParser.cpp
+    ../../parse/ReportParseError.cpp
+    ../../parse/ShipDesignsParser.cpp
+    ../../parse/ShipHullsParser.cpp
+    ../../parse/ShipPartsParser.cpp
+    ../../parse/SpecialsParser.cpp
+    ../../parse/SpeciesParser.cpp
+    ../../parse/StarTypeValueRefParser.cpp
+    ../../parse/StringValueRefParser.cpp
+    ../../parse/TechsParser.cpp
+    ../../parse/UniverseObjectTypeValueRefParser.cpp
     ../../universe/Building.cpp
     ../../universe/Condition.cpp
     ../../universe/ConditionParser1.cpp
@@ -97,6 +128,7 @@
     ../../universe/Enums.cpp
     ../../universe/Fleet.cpp
     ../../universe/Meter.cpp
+    ../../universe/Names.cpp
     ../../universe/ObjectMap.cpp
     ../../universe/ParserUtil.cpp
     ../../universe/Planet.cpp
Index: client/AI/CMakeLists.txt
===================================================================
--- client/AI/CMakeLists.txt	(revision 4463)
+++ client/AI/CMakeLists.txt	(working copy)
@@ -23,6 +23,37 @@
     ../../network/Message.cpp
     ../../network/MessageQueue.cpp
     ../../network/Networking.cpp
+    ../../parse/AlignmentsParser.cpp
+    ../../parse/BuildingsParser.cpp
+    ../../parse/ConditionParser1.cpp
+    ../../parse/ConditionParser2.cpp
+    ../../parse/ConditionParser3.cpp
+    ../../parse/ConditionParser.cpp
+    ../../parse/Double.cpp
+    ../../parse/DoubleValueRefParser.cpp
+    ../../parse/EffectParser.cpp
+    ../../parse/EnumParser.cpp
+    ../../parse/FleetPlansParser.cpp
+    ../../parse/Int.cpp
+    ../../parse/IntValueRefParser.cpp
+    ../../parse/ItemsParser.cpp
+    ../../parse/Label.cpp
+    ../../parse/Lexer.cpp
+    ../../parse/MonsterFleetPlansParser.cpp
+    ../../parse/Parse.cpp
+    ../../parse/PlanetEnvironmentValueRefParser.cpp
+    ../../parse/PlanetSizeValueRefParser.cpp
+    ../../parse/PlanetTypeValueRefParser.cpp
+    ../../parse/ReportParseError.cpp
+    ../../parse/ShipDesignsParser.cpp
+    ../../parse/ShipHullsParser.cpp
+    ../../parse/ShipPartsParser.cpp
+    ../../parse/SpecialsParser.cpp
+    ../../parse/SpeciesParser.cpp
+    ../../parse/StarTypeValueRefParser.cpp
+    ../../parse/StringValueRefParser.cpp
+    ../../parse/TechsParser.cpp
+    ../../parse/UniverseObjectTypeValueRefParser.cpp
     ../../UI/StringTable.cpp
     ../../universe/Building.cpp
     ../../universe/Condition.cpp
@@ -35,6 +66,7 @@
     ../../universe/EffectParser.cpp
     ../../universe/Enums.cpp
     ../../universe/Fleet.cpp
+    ../../universe/Names.cpp
     ../../universe/Meter.cpp
     ../../universe/ObjectMap.cpp
     ../../universe/ParserUtil.cpp
@@ -134,7 +166,7 @@
     link_directories(${BOOST_LIBRARYDIR})
     set(THIS_EXE_LINK_LIBS ${THIS_EXE_LINK_LIBS} ${GIGI_GIGI_LIBRARY} ${ZLIB_LIBRARY})
 else ()
-    set(THIS_EXE_LINK_LIBS ${THIS_EXE_LINK_LIBS} ${Boost_LIBRARIES} ${ZLIB_LIBRARY})
+    set(THIS_EXE_LINK_LIBS ${THIS_EXE_LINK_LIBS} ${GIGI_GIGI_LIBRARY} ${Boost_LIBRARIES} ${ZLIB_LIBRARY})
 endif ()
 
 executable_all_variants(freeorionca)
